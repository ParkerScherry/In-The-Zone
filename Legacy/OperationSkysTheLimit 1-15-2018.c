#pragma config(Sensor, in1,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    DaButton,       sensorAnalog)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LED1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  LED2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  LED3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  LED4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  LED5,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED6,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LED7,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, Jumper,         sensorDigitalIn)
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           RightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ClawMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftMobile,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightMobile,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*===================================================================*\
| Meme................................................................|
|---------------------------------------------------------------------|
| used to illustrate the fact that Eric is very sexist and this is    |
| now used to make our user control work                              |
\*===================================================================*/
bool Eric = true;
bool RespectsWomen = false;

/*===================================================================*\
| Initilize Global Variables..........................................|
|---------------------------------------------------------------------|
| these variables are used in methods that deal with auton all the    |
| way to decalaring variables for battery voltage                     |
\*===================================================================*/
int testNum = 0;
int eDriveTicks = 392;
int wheelDiameter = 4;
int myAutonomous = 100;
int liftHold = 10;
bool userPot = false;
bool showBattery = false;
string mainBattery, backupBattery;

/*===================================================================*\
| Auton Names.........................................................|
|---------------------------------------------------------------------|
| declares the constant strings for the different auton names that    |
| are then displayed on the LCD display, also contains the open and   |
| close string for the claw method for easier use                     |
\*===================================================================*/
const string autonOne = "Skills";
const string autonTwo = "North Union Red";
const string autonThree = "North Union Blue";
const string autonFour = "Im Sorry";
const string autonFive = "NULL";
const string autonSix = "High Goal Red";
const string autonSeven = "High Goal Blue";
const string autonEight = "Mobile Red";
const string autonNine = "Mobile Blue";
const string autonTen = "Special";
const string autonEleven = "NULL";
const string autonTwelve = "NULL";
const string autonTest = "Test";
string open = "open";
string close = "close";

/*===================================================================*\
| LED.................................................................|
|---------------------------------------------------------------------|
| used in the NightRider task as an easy way to shut off all the      |
| lights                                                              |
\*===================================================================*/
void lightEmittingDiode (int power){
	SensorValue[LED1] = power;
	SensorValue[LED2] = power;
	SensorValue[LED3] = power;
	SensorValue[LED4] = power;
	SensorValue[LED5] = power;
	SensorValue[LED6] = power;
	SensorValue[LED7] = power;
}

/*------------------------------------------------------------------*\
//	______               _
//	| ___ \             | |
//	| |_/ /___  ___  ___| |_ ___
//	|    // _ \/ __|/ _ \ __/ __|
//	| |\ \  __/\__ \  __/ |_\__ \
//	\_| \_\___||___/\___|\__|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Resets Drive Encoder................................................|
|---------------------------------------------------------------------|
| sets the drive encoders to 0 to then be used throughout the methods |
\*===================================================================*/
void setDrive (){
	// resets encoder values to 0
	SensorValue(LeftEncoder) = 0;
	SensorValue(RightEncoder) = 0;
}

/*===================================================================*\
| Resets Gyro.........................................................|
|---------------------------------------------------------------------|
| sets the gyro value to 0 to then be used throughout the methods     |
\*===================================================================*/
void setGyro (){
	// resets the gyro value to 0
	SensorValue(Gyro) = 0;
}

/*===================================================================*\
| Initilize Sensors...................................................|
|---------------------------------------------------------------------|
| completly wipes out all data in the sensors then re-declares them   |
\*===================================================================*/
void intSensor (){
	// sets sensor type to none to start the full sensor reset
	SensorType[Gyro] = sensorNone;
	SensorType[LeftEncoder] = sensorNone;
	SensorType[RightEncoder] = sensorNone;
	// waits 1 sec before setting all the sensors
	wait1Msec(1000);
	SensorType[Gyro] = sensorGyro;
	SensorType[LeftEncoder] = sensorQuadEncoder;
	SensorType[RightEncoder] = sensorQuadEncoder;
	// waits 2 seconds to let gyro initilize properly
	// DO NOT MOVE WHILE THIS IS HAPPENING
	wait1Msec(2000);
}

/*------------------------------------------------------------------*\
//	 _____ _
//	/  ___| |
//	\ `--.| |_ ___  _ __  ___
//	 `--. \ __/ _ \| '_ \/ __|
//	/\__/ / || (_) | |_) \__ \
//	\____/ \__\___/| .__/|___/
//							   |_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Stop Drive..........................................................|
|---------------------------------------------------------------------|
| completly stops the drive motors, used in auton methods             |
\*===================================================================*/
void stopDrive (){
	// stops drive motors
	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
}

/*===================================================================*\
| Stop Lift...........................................................|
|---------------------------------------------------------------------|
| reduces the lift power to 10 inorder to stop it from moving and     |
| holds the lift better in current position                           |
\*===================================================================*/
void stopLift (){
	// stops / holds the lift
	motor[RightLift] = liftHold;
	motor[LeftLift] = liftHold;
}

/*===================================================================*\
| Stop Mobile Goal....................................................|
|---------------------------------------------------------------------|
| completly stops the mobile goal lift motors                         |
\*===================================================================*/
void stopMobile (){
	// stop mobile goal motors
	motor[RightMobile] = 0;
	motor[LeftMobile] = 0;
}

/*------------------------------------------------------------------*\
//	______      _
//	|  _  \    (_)
//	| | | |_ __ ___   _____
//	| | | | '__| \ \ / / _ \
//	| |/ /| |  | |\ V /  __/
//	|___/ |_|  |_| \_/ \___|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Drive Time..........................................................|
|---------------------------------------------------------------------|
| allows the use for timing when controling the drive, but also uses  |
| the drive straight commands                                         |
\*===================================================================*/
void driveTime (int speed, int mSec, bool clawHold = false){
	// initilize variable used for right side multiplier
	float rModMulti = .01;
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;
	// starts the timer used for the method
	clearTimer(T2);

	// checks for the current time and compares to desiered time
	while (time1[T2] < mSec){
		// calculates the right side modification that needs to be applied
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// applies desiered motor speed
		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;
	}
	// stops the drive motors
	stopDrive ();
}

/*===================================================================*\
| Drive Encoder...... ................................................|
|---------------------------------------------------------------------|
| allows for fine control of the drive, incorperating the use of      |
| inches to and driving straight to be percise in auton               |
\*===================================================================*/
void driveEncoder (int speed, float distance, bool clawHold = false){
	// sets encoders to 0
	setDrive ();
	// calculates the amount of ticks required to reach a set amount of distance (in) using
	// the wheel diameter, PI, and the power of the motor
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	// initilize variable used for right side multiplier
	float rModMulti = .01;
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;

	// checks for the first 10% of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks * .1){
		// calculates the right side modification that needs to be applied
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// reduces the power of the motors to account for drift
		motor[RightDrive] = speed/1.5;
		motor[LeftDrive] = speed/1.5 + rMod;
	}

	// checks for the majority (10% - 80%) of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks * .7){
		// calculates the right side modification that needs to be applied
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// applies the desiered power from the method call
		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;
	}

	// checks for the last 20% of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks){
		// calculates the right side modification that needs to be applied
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// reduces the power of the motor to account for drift as the robot stops
		motor[RightDrive] = speed/3;
		motor[LeftDrive] = speed/3 + rMod;
	}
	// stops the drive motors
	stopDrive ();
}

/*===================================================================*\
| Turn Time...........................................................|
|---------------------------------------------------------------------|
| used to control turns based on time rather than gyro, mostly used   |
| in the turn gyro function to help stop it                           |
\*===================================================================*/
void turnTime (int speed, int mSec){
	// sets the drive motors to turn using a set power
	motor[RightDrive] = -speed;
	motor[LeftDrive] = speed;
	// waits the set amout of mSec to carry out the method
	wait1Msec(mSec);
	stopDrive ();
}

/*===================================================================*\
| Turn Gyro...........................................................|
|---------------------------------------------------------------------|
| uses the gyroscope to accuratly perform turns along with reducing   |
| speed of the turn as the turn progresses                            |
\*===================================================================*/
void turnGyro (int speed, int degrees, bool clawHold = false){
	// sets the gyro value to 0
	setGyro ();
	// calucated the amount required to turn as degrees
	// multiplies by the gyro error for percise turns
	int ticks = degrees * 10;
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;

	// checks for the first 60% of the turn
	while (abs(SensorValue(Gyro)) < ticks * .6){
		// sets motor values to desiered power from the method call
		motor[RightDrive] = -speed;
		motor[LeftDrive] = speed;
	}

	// checks for the next 20% of the turn
	while (abs(SensorValue(Gyro)) < ticks * .8){
		// sets the motor values to a reduced about of power as it
		// reaches the set tick value
		motor[RightDrive] = -speed * .8;
		motor[LeftDrive] = speed * .8;
	}

	// checks for the last 20% of the turn
	while (abs(SensorValue(Gyro)) < ticks){
		// sets the motor values to an even reduced about of power
		// as it reaches the set tick value to stop drift
		motor[RightDrive] = -speed * .55;
		motor[LeftDrive] = speed * .55;
	}
	// briefly moves in the opposite direction for 150 mSec
	turnTime (-speed/2, 150);
}

/*------------------------------------------------------------------*\
//	 _____ _
//	/  __ \ |
//	| /  \/ | __ ___      __
//	| |   | |/ _` \ \ /\ / /
//	| \__/\ | (_| |\ V  V /
//	 \____/_|\__,_| \_/\_/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Claw................................................................|
|---------------------------------------------------------------------|
| controls the claw in auton by using an input of open or close       |
\*===================================================================*/

void claw (string action){
	// checks if the claw is going to be closing
	if (action == "close"){
		// sets motor power to full for speed and power
		motor[ClawMotor] = 127;
		wait1Msec(400);
	}
	// checks if the claw is going to be opening
	else if (action == "open"){
		// slowly closes the claw briefly to bring to perfect spot to collect more cones
		motor[ClawMotor] = -80;
		wait1Msec(110);
	}
	// stops the claw motor
	motor[ClawMotor] = 0;
}

/*------------------------------------------------------------------*\
//	 _     _  __ _
//	| |   (_)/ _| |
//	| |    _| |_| |_ ___
//	| |   | |  _| __/ __|
//	| |___| | | | |_\__ \
//	\_____/_|_|  \__|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Mobile Lift.........................................................|
|---------------------------------------------------------------------|
| moves the mobile goal lift for a specified time and power           |
\*===================================================================*/

// ------------------------------------------------------------------- Mobile Lift
void mLift (int speed, int time){
	// sets mobile goal lift to desiered power
	motor[RightMobile] = speed;
	motor[LeftMobile] = speed;
	// lets motors move for desiered time
	wait1Msec(time);
	// stop mobile goal motors
	stopMobile ();
}

/*===================================================================*\
| Lift Time...........................................................|
|---------------------------------------------------------------------|
| controls the lift while using time instead of potentiometer values, |
| helps prevent lift from getting stuck/ never reaching pot values    |
\*===================================================================*/
void liftTime (int speed, int time, bool clawHold = false){
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;

	// sets the lift speed
	motor[RightLift] = speed;
	motor[LeftLift] = speed;
	// lets the method carry out for the set time
	wait1Msec(time);
	// stops the lift
	stopLift ();
}

/*===================================================================*\
| Lift Potentiometer..................................................|
|---------------------------------------------------------------------|
| controls the lift using the potentiometer, used to reach percise    |
| heights in auton                                                    |
\*===================================================================*/
void lift (int speed, int height, bool clawHold = false){
	// initilize the current height to what it is when the method starts
	int currentHeight = SensorValue(LiftPot);
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;

	// checks if the lift is moving down
	if (height - currentHeight > 0){
		// loops the method while the lift pot is less than the desiered height
		while (SensorValue(LiftPot) < height){
			// sets lift power to move down and reduces power to account for gravity
			motor[RightLift] = -speed * 0.6;
			motor[LeftLift] = -speed * 0.6;
		}
		// stops the lift motors
		stopLift ();
	}

	// checks if the lift is moving down
	else {
		// loops the method while the lift pot is more than the desiered height
		while (SensorValue(LiftPot) > height){
			// sets lift power to move up at desiered power
			motor[RightLift] = speed;
			motor[LeftLift] = speed;
		}
		// stops the lift motors
		stopLift ();
	}
}

/*===================================================================*\
| Drive And Lift......................................................|
|---------------------------------------------------------------------|
| allows the ability to control the drive and lift during auton at    |
| the same time while still using the sensors from each which means   |
| being able to drive straigh and reach percise heights               |
\*===================================================================*/
void driveLift (int driveSpeed, float distance, int liftSpeed, int height, bool clawHold = false){
	// sets encoders to 0
	setDrive ();
	// calculates the amount of ticks required to reach a set amount of distance (in) using
	// the wheel diameter, PI, and the power of the motor
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	// initilize variable used for right side multiplier
	float rModMulti = .01;
	// checks if the claw need to be hold throughout the method
	if (clawHold)
		motor[ClawMotor] = 30;
	else
		motor[ClawMotor] = 0;

	// checks if lift is moving up
	if (SensorValue[LiftPot] > height){
		// loops while the robot has not reached tick count or until it reaches desiered height
		// the +400 to height allows for more accurate movements that corrispond to the input of height
		while ((abs(SensorValue[LeftEncoder]) < ticks) && (SensorValue[LiftPot] > height + 400)){
			// calculates the right side modification that needs to be applied
			int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
			float rMod = sgn(rDiff) * driveSpeed * rModMulti;

			// applies the desiered power form the method call
			motor[RightDrive] = driveSpeed;
			motor[LeftDrive] = driveSpeed + rMod;
			motor[RightLift] = liftSpeed;
			motor[LeftLift] = liftSpeed;
		}
	}

	// checks if lift is moving up down
	else {
		// loops while the robot has not reached tick count or until it reaches desiered height
		// the -200 to height allows for more accurate movements that corrispond to the input of height
		while ((abs(SensorValue[LeftEncoder]) < ticks) && (SensorValue[LiftPot] < height - 200)){
			// calculates the right side modification that needs to be applied
			int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
			float rMod = sgn(rDiff) * driveSpeed * rModMulti;

			// applies the desiered power form the method call
			// inverts the power of the lift
			motor[RightDrive] = driveSpeed;
			motor[LeftDrive] = driveSpeed + rMod;
			motor[RightLift] = -liftSpeed;
			motor[LeftLift] = -liftSpeed;
		}
	}
	motor[RightLift] = 0;
	motor[LeftLift] = 0;

	// checks if reached the tick amount first
	if ((abs(SensorValue[LeftEncoder]) > ticks)){
		// checks if lift needs to still move up
		if (SensorValue[LiftPot] > height){
			// loops while the lift need to reach set height value
			while (SensorValue[LiftPot] > height + 400){
				// sets lift power to desiered
				// stops drive because it has reached destination
				motor[RightLift] = liftSpeed;
				motor[LeftLift] = liftSpeed;
				stopDrive ();
			}
		}

		// checks if lift needs to still move down
		else {
			// loops while the lift need to reach set height value
			while (SensorValue[LiftPot] < height - 200){
				// inverts lift power to move down
				// stops drive because it has reached destination
				motor[RightLift] = -liftSpeed;
				motor[LeftLift] = -liftSpeed;
				stopDrive ();
			}
		}
	}

	// checks if reached the lift reached height first and still needs to move up
	if (SensorValue[LiftPot] > height){
		// loops while encoder is less than ticks
		while ((abs(SensorValue[LeftEncoder]) < ticks)){
			// calculates the right side modification that needs to be applied
			int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
			float rMod = sgn(rDiff) * driveSpeed * rModMulti;

			// sets drive power to desiered
			// stops lift because it has reached destination
			motor[RightDrive] = driveSpeed;
			motor[LeftDrive] = driveSpeed + rMod;
			stopLift ();
		}
	}

	// checks if reached the lift reached height first and still needs to move down
	else {
		// loops while encoder is less than ticks
		while((abs(SensorValue[LeftEncoder]) < ticks)){
			// calculates the right side modification that needs to be applied
			int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
			float rMod = sgn(rDiff) * driveSpeed * rModMulti;

			// sets drive power to desiered
			// stops lift because it has reached destination
			motor[RightDrive] = driveSpeed;
			motor[LeftDrive] = driveSpeed + rMod;
			stopLift ();
		}
	}
	// stops lift and drive motors
	stopLift ();
	stopDrive ();
}

/*------------------------------------------------------------------*\
// 	 _     ___________
//	| |   /  __ \  _  \
//	| |   | /  \/ | | |
//	| |   | |   | | | |
//	| |___| \__/\ |/ /
//	\_____/\____/___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Display LCD.........................................................|
|---------------------------------------------------------------------|
| displays the current auton that is selcted on the LCD               |
\*===================================================================*/
void displayLCD(){
	switch (myAutonomous)
	{
	case 0:
		displayLCDCenteredString(0, autonOne);displayLCDCenteredString(1, "Selected");break;
	case 1:
		displayLCDCenteredString(0, autonTwo);displayLCDCenteredString(1, "Selected");break;
	case 2:
		displayLCDCenteredString(0, autonThree);displayLCDCenteredString(1, "Selected");break;
	case 3:
		displayLCDCenteredString(0, autonFour);displayLCDCenteredString(1, "Selected");break;
	case 4:
		displayLCDCenteredString(0, autonFive);displayLCDCenteredString(1, "Selected");break;
	case 5:
		displayLCDCenteredString(0, autonSix);displayLCDCenteredString(1, "Selected");break;
	case 6:
		displayLCDCenteredString(0, autonSeven);displayLCDCenteredString(1, "Selected");break;
	case 7:
		displayLCDCenteredString(0, autonEight);displayLCDCenteredString(1, "Selected");break;
	case 8:
		displayLCDCenteredString(0, autonNine);displayLCDCenteredString(1, "Selected");break;
	case 9:
		displayLCDCenteredString(0, autonTen);displayLCDCenteredString(1, "Selected");break;
	case 10:
		displayLCDCenteredString(0, autonEleven);displayLCDCenteredString(1, "Selected");break;
	case 11:
		displayLCDCenteredString(0, autonTwelve);displayLCDCenteredString(1, "Selected");break;
	default:
		displayLCDCenteredString(0, autonTest);displayLCDCenteredString(1, "Selected");break;
	}
}

/*===================================================================*\
| Auton Setter........................................................|
|---------------------------------------------------------------------|
| sets the auton and shows the menu display to select an auton        |
\*===================================================================*/
void autoSetter (int value, bool select = false){
	clearLCDLine(0);
	clearLCDLine(1);
	// saves auton in gloabal variable
	if (select)
		myAutonomous = value;

	//displays set or select accordingly
	if(myAutonomous == value)
		displayLCDCenteredString(1, ">SET<");
	else
		displayLCDCenteredString(1, ">select<");

	// shows auton names
	switch(value)
	{
	case 0:
		displayLCDCenteredString(0, autonOne); break;
	case 1:
		displayLCDCenteredString(0, autonTwo); break;
	case 2:
		displayLCDCenteredString(0, autonThree); break;
	case 3:
		displayLCDCenteredString(0, autonFour); break;
	case 4:
		displayLCDCenteredString(0, autonFive); break;
	case 5:
		displayLCDCenteredString(0, autonSix); break;
	case 6:
		displayLCDCenteredString(0, autonSeven); break;
	case 7:
		displayLCDCenteredString(0, autonEight); break;
	case 8:
		displayLCDCenteredString(0, autonNine); break;
	case 9:
		displayLCDCenteredString(0, autonTen); break;
	case 10:
		displayLCDCenteredString(0, autonEleven); break;
	case 11:
		displayLCDCenteredString(0, autonTwelve); break;
	default:
		displayLCDCenteredString(0, autonTest); break;
	}
}

/*===================================================================*\
| Auton Selector......................................................|
|---------------------------------------------------------------------|
| the framework for being able to use the menu system on the LCD      |
\*===================================================================*/
void autoSelector(){
	// sets choice to 0
	int choice = 0;
	autoSetter(0);

	while (vexRT[Btn7U] != 1){
		if ((vexRT[Btn7L] == 1) || (vexRT[Btn7R] == 1)){
			// previous choice
			if (vexRT[Btn7L] == 1){
				if (--choice < 0){
					choice = 9;
				}
			}
			// next choice
			if (vexRT[Btn7R] == 1){
				if (++choice > 9){
					choice = 0;
				}
			}
			autoSetter(choice);
		}

		// select choice
		if (vexRT[Btn7D] == 1)
			autoSetter(choice, true);
		wait1Msec(120);
	}
	wait1Msec(200);
	return;
}

/*------------------------------------------------------------------*\
//	 _____         _
//	|_   _|       | |
//	  | | __ _ ___| | _____
//	  | |/ _` / __| |/ / __|
//	  | | (_| \__ \   <\__ \
//	  \_/\__,_|___/_|\_\___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Battery Voltage.....................................................|
|---------------------------------------------------------------------|
| calculates and displays the current battery voltage on the LCD      |
\*===================================================================*/
task batteryVoltage () // source http://www.robotc.net/blog/2012/05/18/advanced-applications-with-the-vex-lcd/
{
	while(true)                                                  // An infinite loop to keep the program running until you terminate it
	{
		clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
		clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
		displayNextLCDString(backupBattery);

		//Short delay for the LCD refresh rate
		wait1Msec(100);
	}
	EndTimeSlice();
}

/*===================================================================*\
| Lift Driver Load....................................................|
|---------------------------------------------------------------------|
| controls the ability to do move the lift to the driver load height  |
| in user control                                                     |
\*===================================================================*/
task driverLoad ()
{
	// initilize the current height to what it is when the method starts
	int currentHeight = SensorValue(LiftPot);

	// checks if the lift is moving down
	if (2300 - currentHeight > 0){
		// loops the method while the lift pot is less than 1950
		while (SensorValue(LiftPot) < 1950){
			// sets lift power to move down and reduces power to account for gravity
			motor[RightLift] = -60;
			motor[LeftLift] = -60;
		}
		// stops the lift motors
		stopLift ();
	}

	// checks if the lift is moving up
	else {
		// loops the method while the lift pot is more than 2500
		while (SensorValue(LiftPot) > 2485){
			// sets lift power to move up at 100
			motor[RightLift] = 100;
			motor[LeftLift] = 100;
		}
		// stops the lift motors
		stopLift ();
	}
	// sets to true to hold lift in place during user control
	userPot = true;
	stopTask (driverLoad);
}

/*===================================================================*\
| resetMobileGoal.....................................................|
|---------------------------------------------------------------------|
| resets the mobile to the down position from anywhere                |
\*===================================================================*/
task resetMobileGoal (){
	// loops while the button is not pressed
	while (SensorValue[DaButton] > 0){
		// moves mobile goal back at a reduced speed
		motor[RightMobile] = -80;
		motor[LeftMobile] = -80	;
	}
	// stops mobile goal motors
	stopMobile ();
	// stops the task
	stopTask (resetMobileGoal);
}

/*===================================================================*\
| Night Rider.........................................................|
|---------------------------------------------------------------------|
| makes our cortex look cool                                          |
\*===================================================================*/
task NightRider (){
	while (true){
		lightEmittingDiode (0);
		SensorValue[LED1] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED2] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED3] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED4] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED5] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED6] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED7] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED6] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED5] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED4] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED3] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED2] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED1] = 1;
	}
	EndTimeSlice();
}

/*------------------------------------------------------------------*\
//	 _   _ _       _       _____             _
//	| | | (_)     | |     |  __ \           | |
//	| |_| |_  __ _| |__   | |  \/ ___   __ _| |
//	|  _  | |/ _` | '_ \  | | __ / _ \ / _` | |
//	| | | | | (_| | | | | | |_\ \ (_) | (_| | |
//	\_| |_/_|\__, |_| |_|  \____/\___/ \__,_|_|
// 	          __/ |
//	         |___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Red.................................................................|
|---------------------------------------------------------------------|
| Done: Left, Right                                                   |
\*===================================================================*/
void highGoalRedRight (){
	char HighGoal_RedRight;

	// score preload cone on high goal
	claw (close);
	driveLift (100, 11, 100, 1500, true);
	wait1Msec(300);
	liftTime (-80, 200);
	claw (open);
	wait1Msec(300);
	// back off and turn for second cone
	driveEncoder (-100, 5);
	turnGyro (90, 103);
	wait1Msec(300);
	driveLift (100, 4.5, 100, 2800);
	// pick up second cone
	claw (close);
	liftTime (100, 300, true);
	wait1Msec(300);
	turnGyro (-90, 148, true);
	wait1Msec(300);
	// score second cone
	driveLift (100, 9, 100, 1300, true);
	wait1Msec(300);
	liftTime (-80, 300, true);
	claw (open);
	wait1Msec(300);
	// back off and turn for third cone
	driveEncoder (-100, 5);
	turnGyro (90, 158);
	wait1Msec(300);
	driveLift (100, 6.5, 100, 2800);
	// pick up third cone
	claw (close);
	liftTime (100, 300, true);
	wait1Msec(300);
	turnGyro (-90, 180, true);
	// score third cone
	driveLift (100, 22, 100, 1180, true);
	liftTime (-80, 300, true);
	wait1Msec(300);
	// back off
	claw (open);
	driveLift (-127, 8, 100, 2800);
}

void highGoalRedLeft (){
	char HighGoal_RedLeft;

	// score preload cone on high goal
	claw (close);
	driveLift (100, 11, 100, 1500, true);
	wait1Msec(300);
	liftTime (-80, 200);
	claw (open);
	wait1Msec(300);
	// back off and turn for second cone
	driveEncoder (-100, 5);
	turnGyro (-90, 93);
	wait1Msec(300);
	driveLift (90, 23, 100, 2800);
	// pick up second cone
	claw (close);
	liftTime (100, 200, true);
	driveEncoder (-90, 20, true);
	wait1Msec(300);
	turnGyro (90, 125, true);
	wait1Msec(300);
	// score second cone
	lift (100, 1300, true);
	driveEncoder (90, 5, true);
	wait1Msec(300);
	liftTime (-100, 300, true);
	claw (open);
	// drive tword third cone
	driveEncoder (-100, 7);
	turnGyro (-100, 130);
	driveLift (100, 18, 100, 2800);
	wait1Msec(300);
	claw (close);
}

/*===================================================================*\
| Blue................................................................|
|---------------------------------------------------------------------|
| Done: Left, Right                                                   |
\*===================================================================*/
void highGoalBlueRight (){
	char HighGoal_BlueRight;

	// score preload cone on high goal
	claw (close);
	driveLift (100, 11, 100, 1500, true);
	wait1Msec(300);
	liftTime (-80, 200);
	claw (open);
	wait1Msec(300);
	// back off and turn for second cone
	driveEncoder (-100, 5);
	turnGyro (90, 91);
	wait1Msec(300);
	driveLift (90, 23, 100, 2800);
	// pick up second cone
	claw (close);
	liftTime (100, 200, true);
	driveEncoder (-90, 20, true);
	wait1Msec(300);
	turnGyro (-90, 133, true);
	wait1Msec(300);
	// score second cone
	lift (100, 1300, true);
	driveEncoder (90, 5, true);
	wait1Msec(300);
	liftTime (-100, 300, true);
	claw (open);
	// drive tword third cone
	driveEncoder (-100, 7);
	turnGyro (100, 140);
	driveLift (100, 18, 100, 2800);
	wait1Msec(300);
	claw (close);
}

void highGoalBlueLeft (){
	char HighGoal_BlueLeft;

	// score preload cone on high goal
	claw (close);
	driveLift (100, 11, 100, 1500, true);
	wait1Msec(300);
	liftTime (-80, 200);
	claw (open);
	wait1Msec(300);
	// back off and turn for second cone
	driveEncoder (-100, 5);
	turnGyro (-90, 105);
	wait1Msec(300);
	driveLift (100, 4.5, 100, 2800);
	// pick up second cone
	claw (close);
	liftTime (100, 300, true);
	wait1Msec(300);
	turnGyro (90, 142, true);
	wait1Msec(300);
	// score second cone
	driveLift (100, 8, 100, 1300, true);
	wait1Msec(300);
	liftTime (-80, 300, true);
	claw (open);
	wait1Msec(300);
	// back off and turn for third cone
	driveEncoder (-100, 5);
	turnGyro (-90, 160);
	wait1Msec(300);
	driveLift (100, 6.5, 100, 2800);
	// pick up third cone
	claw (close);
	liftTime (100, 300, true);
	wait1Msec(300);
	turnGyro (90, 178, true);
	// score third cone
	driveLift (100, 22, 100, 1180, true);
	liftTime (-80, 300, true);
	wait1Msec(300);
	// back off
	claw (open);
	driveLift (-127, 8, 100, 2800);
}


/*------------------------------------------------------------------*\
//	___  ___      _     _ _        _____             _
//	|  \/  |     | |   (_) |      |  __ \           | |
//	| .  . | ___ | |__  _| | ___  | |  \/ ___   __ _| |
//	| |\/| |/ _ \| '_ \| | |/ _ \ | | __ / _ \ / _` | |
//	| |  | | (_) | |_) | | |  __/ | |_\ \ (_) | (_| | |
//	\_|  |_/\___/|_.__/|_|_|\___|  \____/\___/ \__,_|_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Red.................................................................|
|---------------------------------------------------------------------|
| Done: none                                                          |
\*===================================================================*/
void mobileGoalRed (){
	char MobileGoal_Red;

}

/*===================================================================*\
| Blue................................................................|
|---------------------------------------------------------------------|
| Done: none                                                          |
\*===================================================================*/
void mobileGoalBlue (){
	char MobileGoal_Blue;

}

/*------------------------------------------------------------------*\
//	 _____     _
//	|  ___|   | |
//	| |____  _| |_ _ __ __ _ ___
//	|  __\ \/ / __| '__/ _` / __|
//	| |___>  <| |_| | | (_| \__ \
//	\____/_/\_\\__|_|  \__,_|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Skills..............................................................|
|---------------------------------------------------------------------|
| Points: 50                                                          |
\*===================================================================*/
void skills (){
	char skills;

	// pick up first mobile goal
	driveEncoder (-80, 24);
	mLift (120, 1150);
	driveEncoder (80, 19);
	wait1Msec(300);
	turnGyro (-70, 97);
	wait1Msec(300);
	driveEncoder (-80, 8);
	turnGyro (-70, 90);
	// scores first mobile goal
	driveTime (-127, 1200);
	wait1Msec(300);
	driveEncoder (70, 18);
	startTask (resetMobileGoal);
	turnGyro (-70, 90);
	// picks up second mobile goal
	wait1Msec(300);
	driveEncoder (80, 12);
	wait1Msec(500);
	turnGyro (-70, 77);
	wait1Msec(500);
	driveEncoder (-120, 23);
	mLift (120, 850);
	// scores second mobile goal
	driveEncoder (80, 11);
	wait1Msec(500);
	turnGyro (70, 170);
	wait1Msec(500);
	driveEncoder (-80, 3);
	driveTime (-127, 600);
	// turns for third mobile goal
	driveEncoder (90, 7);
	startTask (resetMobileGoal);
	wait1Msec(500);
	turnGyro (75, 190);
	wait1Msec(500);
	// bull doze time
	driveEncoder (-100, 40);
	mLift (120, 1150);
	driveEncoder (-100, 25);
	wait1Msec(300);
	turnGyro (90, 90);
	wait1Msec(300);
	driveEncoder (-100, 8);
	wait1Msec(300);
	turnGyro (-90, 83);
	wait1Msec(300);
	driveTime (-127, 1200);
	// picks up fourth goal
	driveEncoder (70, 15);
	startTask (resetMobileGoal);
	wait1Msec(200);
	turnGyro (80, 90);
	driveEncoder (-90, 10);
	turnGyro (80, 96);
	wait1Msec(300);
	driveEncoder (-90, 20);
	mLift (120, 850);
	// score fourth goal
	wait1Msec(500);
	turnGyro (90, 180);
	wait1Msec(500);
	driveEncoder (-80, 7);
	driveTime (-120, 1000);
	// back off to grab fifth goal
	driveEncoder (100, 2);
	wait1Msec(300);
	turnGyro (-85, 90);
	wait1Msec(300);
	driveEncoder (-100, 22);
	wait1Msec(300);
	turnGyro (-90, 35);
	wait1Msec(300);
	startTask (resetMobileGoal);
	driveEncoder (-100, 20);
	driveTime (-100, 500);
	// pick up fifth goal
	mLift (120, 1100);
	driveEncoder (100, 30);
	turnGyro (100, 45);
	driveEncoder (100, 6);
	turnGyro (100, 100);
	// score final goal
	driveTime (-127, 800);
	driveTime (127, 850);
	turnGyro (100, 30);
	driveTime (127, 600);

}

/*===================================================================*\
| Test................................................................|
|---------------------------------------------------------------------|
|                                                                     |
\*===================================================================*/
void operationSkysTheLimit (){
	char operationSkysTheLimit;

	// arming sequence
	lift (120, 2500);
	// blast off
	driveTime (120, 10000);
}

/*===================================================================*\
| Test................................................................|
|---------------------------------------------------------------------|
|                                                                     |
\*===================================================================*/
void test (){
	char test;


}

/*===================================================================*\
| Special.............................................................|
|---------------------------------------------------------------------|
|                                                                     |
\*===================================================================*/
void special (){
	char special;

}

/*------------------------------------------------------------------*\
//	______            ___        _
//	| ___ \          / _ \      | |
//	| |_/ / __ ___  / /_\ \_   _| |_ ___  _ __
//	|  __/ '__/ _ \ |  _  | | | | __/ _ \| '_ \
//	| |  | | |  __/ | | | | |_| | || (_) | | | |
//	\_|  |_|  \___| \_| |_/\__,_|\__\___/|_| |_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Pre Auton...........................................................|
|---------------------------------------------------------------------|
| resets sensors and starts the NightRider task                       |
| DO NOT MOVE because of the gyro calibration                         |
\*===================================================================*/
void pre_auton(){
	// starts NightRider task because its cool
	startTask (NightRider);
	// set up LCD display
	bLCDBacklight = true;
	displayLCDCenteredString(0, "Do Not Move");
	displayLCDCenteredString(1, "Calibrating");
	// sensor set up
	intSensor ();
	setDrive ();
	// reset mobile goal lift
	//startTask (resetMobileGoal);
}

/*------------------------------------------------------------------*\
//	  ___        _
//	 / _ \      | |
//	/ /_\ \_   _| |_ ___  _ __   ___  _ __ ___   ___  _   _ ___
//	|  _  | | | | __/ _ \| '_ \ / _ \| '_ ` _ \ / _ \| | | / __|
//	| | | | |_| | || (_) | | | | (_) | | | | | | (_) | |_| \__ \
//	\_| |_/\__,_|\__\___/|_| |_|\___/|_| |_| |_|\___/ \__,_|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Autonomous..........................................................|
|---------------------------------------------------------------------|
| starts the autons but actual autons are stored in methods above     |
\*===================================================================*/
task autonomous(){
	clearLCDLine(0);
	clearLCDLine(1);

	switch(myAutonomous)
	{
	case 0: //Skills
		displayLCDCenteredString(0, autonOne); displayLCDCenteredString(1, "Running!"); skills (); break;
	case 1: //High Goal Red
		displayLCDCenteredString(0, autonTwo); displayLCDCenteredString(1, "Running!"); highGoalRedLeft (); break;
	case 2: //High Goal Red L
		displayLCDCenteredString(0, autonThree); displayLCDCenteredString(1, "Running!"); highGoalBlueRight (); break;
	case 3: //High Goal Blue R
		displayLCDCenteredString(0, autonFour); displayLCDCenteredString(1, "Truly I am Sorry"); operationSkysTheLimit (); break;
	case 4: //High Goal Blue L
		displayLCDCenteredString(0, autonFive); displayLCDCenteredString(1, "Running!"); test (); break;
	case 5: //Mobile Goal Red R
		displayLCDCenteredString(0, autonSix); displayLCDCenteredString(1, "Running!"); highGoalRedRight (); break;
	case 6: //Mobile Goal Red L
		displayLCDCenteredString(0, autonSeven); displayLCDCenteredString(1, "Running!"); highGoalBlueLeft (); break;
	case 7: //Mobile Goal Blue R
		displayLCDCenteredString(0, autonEight); displayLCDCenteredString(1, "Running!"); mobileGoalRed (); break;
	case 8: //Mobile Goal Left
		displayLCDCenteredString(0, autonNine); displayLCDCenteredString(1, "Running!"); mobileGoalBlue (); break;
	case 9: //Special
		displayLCDCenteredString(0, autonTen); displayLCDCenteredString(1, "Running!"); special (); break;
	default: //Test
		displayLCDCenteredString(0, autonTest); displayLCDCenteredString(1, "Running!"); test (); break;
	}
	EndTimeSlice();
}

/*------------------------------------------------------------------*\
//	 _   _                 _____             _             _
//	| | | |               /  __ \           | |           | |
//	| | | |___  ___ _ __  | /  \/ ___  _ __ | |_ _ __ ___ | |
//	| | | / __|/ _ \ '__| | |    / _ \| '_ \| __| '__/ _ \| |
//	| |_| \__ \  __/ |    | \__/\ (_) | | | | |_| | | (_) | |
//	 \___/|___/\___|_|     \____/\___/|_| |_|\__|_|  \___/|_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| User Control........................................................|
|---------------------------------------------------------------------|
| controls all the user control related to robot and selection of     |
| auton takes place here                                              |
\*===================================================================*/
task usercontrol(){
	// initilize boolean variables for running auton and claw holding
	bool clawBool = false;
	bool runAuton = false;
	// starts LCD display
	bLCDBacklight = true;
	clearLCDLine (0);
	clearLCDLine (1);
	wait1Msec(100);
	displayLCD();
	// nyeas
	startTask (NightRider);

	// loops while the meme is true
	while(Eric != RespectsWomen){
		if (!runAuton){
			/*===================================================================*\
			| H-Base Control......................................................|
			|---------------------------------------------------------------------|
			| sets deadzones for joystick control and uses arcade controls        |
			\*===================================================================*/
			// initialize drive variables and deadzone
			int X2 = 0, Y1 = 0, threshold = 30;

			// checks deadzone
			if(abs(vexRT[Ch3]) > threshold)
				Y1 = vexRT[Ch3];
			else
				Y1 = 0;
			if(abs(vexRT[Ch4]) > threshold)
				X2 = vexRT[Ch4];
			else
				X2 = 0;

			// sets motor power accordingly
			motor[RightDrive] = Y1 - X2;
			motor[LeftDrive] = Y1 + X2;

			/*===================================================================*\
			| Lift Control........................................................|
			|---------------------------------------------------------------------|
			| sets deadzones for joystick control and inverts lift powers         |
			\*===================================================================*/
			// initilize lift variable
			int L1 = 0;
			// checks deadzone
			if(abs(vexRT[Ch2]) > threshold){
				L1 = vexRT[Ch2];
				// if the joystick is moved it will no long hold in place
				userPot = false;
			}
			else {
				L1 = 0;
				// if user pot is true hold the lift in place
				if (userPot)
					L1 = -liftHold;
			}
			// sets motor power accordingly
			motor[RightLift] = -L1;
			motor[LeftLift] = -L1;
			// starts driverLoad task if button is pressed
			if (vexRT[Btn8L] == 1)
				startTask (driverLoad);

			/*===================================================================*\
			| Mobile Goal Lift....................................................|
			|---------------------------------------------------------------------|
			| uses back buttons to move mobile goal lift up or down accordingly   |
			\*===================================================================*/
			// checks if DaButton is pressed and limits it
			if (SensorValue[DaButton] == 0){
				// checks if other button is pressed
				if (vexRT[Btn6D] == 1){
					// moves lift up
					motor[RightMobile] = 127;
					motor[LeftMobile] = 127;
				}
				// checks if no button is pressed
				else
					// stops power to going to motor
				stopMobile ();
			}

			// checks if button is pressed
			else {
				if (vexRT[Btn5D] == 1){
					// moves lift down
					motor[RightMobile] = -127;
					motor[LeftMobile] = -127;
				}
				// checks if other button is pressed
				else if (vexRT[Btn6D] == 1){
					// moves lift up
					motor[RightMobile] = 127;
					motor[LeftMobile] = 127;
				}
				// checks if no button is pressed
				else
					// stops power to going to motor
				stopMobile ();
				// starts resetMobileGoal task if button is pressed
				if (vexRT[Btn8D] == 1)
					startTask (resetMobileGoal);
			}

			/*===================================================================*\
			| Claw Control........................................................|
			|---------------------------------------------------------------------|
			| moves the claw at full power in desiered direction, when claw is    |
			| held for a duration of time the power is reduced to 50 power        |
			\*===================================================================*/
			// closes claw
			if (vexRT[Btn6U] == 1){
				// starts timer once
				while (clawBool){
					clearTimer(T1);
					clawBool = false;
					break;
				}
				// checks timer
				if (time1[T1] < 500)
					motor[ClawMotor] = 127;
				else if (time1[T1] > 500)
					motor[ClawMotor] = 50;
			}

			// open claw
			else if (vexRT[Btn5U] == 1){
				motor[ClawMotor] = -127;
				clawBool = true;
				testNum++;
			}
			// stops claw from moving
			else {
				motor[ClawMotor] = 0;
				clawBool = true;
			}

			/*===================================================================*\
			| LCD Control.........................................................|
			|---------------------------------------------------------------------|
			| controls the LCD displays like auton selection and battery voltage  |
			| its a mess                                                          |
			\*===================================================================*/
			// opens auton selector
			if (vexRT[Btn7D] == 1)
				autoSelector();
			// opens battery voltage
			if (vexRT[Btn7U] == 1 && !showBattery){
				startTask (batteryVoltage);
				showBattery = true;
				wait1Msec(300);
			}
			else if (vexRT[Btn7U] == 1 && showBattery){
				stopTask (batteryVoltage);
				showBattery = false;
				wait1Msec(300);
			}
			// shows auton selected
			if (!showBattery)
				displayLCD();
			// sets to high goal red
			if (vexRT[Btn7R] == 1)
				myAutonomous = 5;
			// sets to high goal blue
			if (vexRT[Btn7L] == 1)
				myAutonomous = 6;
			//checks for jumper
			if (SensorValue[Jumper] == 0){
				if (vexRT[Btn8U] == 1){
					runAuton = true;
					startTask (autonomous);
				}
			}
			// runs pre auton
			if(nLCDButtons == 2)
				pre_auton ();
			EndTimeSlice();
		}
		else {
			if (vexRT[Btn8R] == 1){
				stopTask (autonomous);
				runAuton = false;
			}
			EndTimeSlice();
		}
	}
}
