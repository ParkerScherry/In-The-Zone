#pragma config(Sensor, in1,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    ClawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           RightDrive,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           MobilePush,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RightLift,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           ClawMotor,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftMobile,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightMobile,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------*\
//	________                              __  .__
//	\_____  \ ______   ________________ _/  |_|__| ____   ____   /\
//	 /   |   \\____ \_/ __ \_  __ \__  \\   __\  |/  _ \ /    \  \/
//	/    |    \  |_> >  ___/|  | \// __ \|  | |  (  <_> )   |  \ /\
//	\_______  /   __/ \___  >__|  (____  /__| |__|\____/|___|  / \/
//	        \/|__|        \/           \/                    \/
//	 ___________           /\
//	/   _____/  | _____.__.)/_____
//	\_____  \|  |/ <   |  |/  ___/
//	/        \    < \___  |\___ \
// /_______  /__|_ \/ ____/____  >
//	       \/     \/\/         \/
//	___________.__
//	\__    ___/|  |__   ____
//	  |    |   |  |  \_/ __ \
//	  |    |   |   Y  \  ___/
//	  |____|   |___|  /\___  >
//	                \/     \/
//	.____    .__        .__  __
//	|    |   |__| _____ |__|/  |_
//	|    |   |  |/     \|  \   __\
//	|    |___|  |  Y Y  \  ||  |
//	|_______ \__|__|_|  /__||__|
//	        \/        \/
\*------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#pragma autonomousDuration(15)

// ------------------------------------------------------------------- Meme
bool Eric = true;
bool RespectsWomen = false;

// ------------------------------------------------------------------- Initilize Variables
int testNum = 0;
int eDriveTicks = 392;
//int eTurnTicks = 6;       //Change
int wheelDiameter = 4;
int myAutonomous = 100;
int liftHold = 10;
bool userPot = false;

// ------------------------------------------------------------------- Auton Names
const string autonOne = "Skills";
const string autonTwo = "North Union Red";
const string autonThree = "North Union Blue";
const string autonFour = "High Goal Red -";
const string autonFive = "High Goal Blue -";
const string autonSix = "HighGoal Red";
const string autonSeven = "HighGoal Blue";
const string autonEight = "Mobile Red";
const string autonNine = "Mobile Blue";
const string autonTen = "Special";
const string autonEleven = "NULL";
const string autonTwelve = "NULL";
const string autonTest = "Test";


// ------------------------------------------------------------------- Resets Drive Encoders
void setDrive ()
{
	SensorValue(LeftEncoder) = 0;
	SensorValue(RightEncoder) = 0;
}

// ------------------------------------------------------------------- Resets Gyro
void setGyro ()
{
	SensorValue(Gyro) = 0;
}

// ------------------------------------------------------------------- Initilizes Gyro
void intSensor ()
{
	SensorType[Gyro] = sensorNone;
	SensorType[LeftEncoder] = sensorNone;
	SensorType[RightEncoder] = sensorNone;
	wait1Msec(500);
	SensorType[Gyro] = sensorGyro;
	SensorType[LeftEncoder] = sensorQuadEncoder;
	SensorType[RightEncoder] = sensorQuadEncoder;
	wait1Msec(1500);
}

// ------------------------------------------------------------------- Drive Time
void driveTime (int speed, int mSec)
{
	motor[RightDrive] = speed;
	motor[LeftDrive] = speed;
	wait1Msec(mSec);
	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
}

// ------------------------------------------------------------------- Drive Encoder
void driveEncoder (int speed, float distance, bool clawHold = false)
{
	setDrive ();
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	float rModMulti = .01;
	if (clawHold)
		motor[ClawMotor] = 30;

	while (abs(SensorValue[LeftEncoder]) < ticks * .1)
	{
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed/1.5;
		motor[LeftDrive] = speed/1.5 + rMod;
	}

	while (abs(SensorValue[LeftEncoder]) < ticks * .7)
	{
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;
	}

	while (abs(SensorValue[LeftEncoder]) < ticks)
	{
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed/3;
		motor[LeftDrive] = speed/3 + rMod;
	}
	driveTime (0, 10);
}

// ------------------------------------------------------------------- Turn Time
void turnTime (int speed, int mSec)
{
	motor[RightDrive] = -speed;
	motor[LeftDrive] = speed;
	wait1Msec(mSec);
	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
}

//// ------------------------------------------------------------------- Turn Encoder
//void turnEncoder (int speed, int ticks, bool clawHold = false) //replace ticks w/ degrees when done
//{
//	setDrive ();
//	//int ticks = degrees * eTurnTicks;
//	if (clawHold)
//		motor[ClawMotor] = 30;

//	while (abs(nMotorEncoder[BackLeft]) < ticks * .6)
//	{
//		int rDiff = abs(nMotorEncoder[BackLeft]) - abs(nMotorEncoder[BackRight]);
//		int rMod = sgn(rDiff) * speed * .1;

//		motor[FrontRight] = -speed - rMod;
//		motor[FrontLeft] = speed;
//		motor[BackRight] = -speed - rMod;
//		motor[BackLeft] = speed;
//	}

//	while (abs(nMotorEncoder[BackLeft]) < ticks)
//	{
//		int rDiff = abs(nMotorEncoder[BackLeft]) - abs(nMotorEncoder[BackRight]);
//		int rMod = sgn(rDiff) * speed * .1;

//		motor[FrontRight] = -speed * .8 - rMod;
//		motor[FrontLeft] = speed * .8;
//		motor[BackRight] = -speed * .8 - rMod;
//		motor[BackLeft] = speed * .8;
//	}
//	turnTime (-speed/2, 150);
//}

// ------------------------------------------------------------------- Turn Gyro
void turnGyro (int speed, int degrees, bool clawHold = false)
{
	setGyro ();
	int ticks = degrees * 10;
	if (clawHold)
		motor[ClawMotor] = 30;

	while (abs(SensorValue(Gyro)) < ticks * .6)
	{
		motor[RightDrive] = -speed;
		motor[LeftDrive] = speed;
	}
	while (abs(SensorValue(Gyro)) < ticks * .8)
	{
		motor[RightDrive] = -speed * .8;
		motor[LeftDrive] = speed * .8;
	}
	while (abs(SensorValue(Gyro)) < ticks)
	{
		motor[RightDrive] = -speed * .55;
		motor[LeftDrive] = speed * .55;
	}
	turnTime (-speed/2, 150);
}

// ------------------------------------------------------------------- Claw Control
void claw (int speed, int time)
{
	motor[ClawMotor] = speed;
	wait1Msec(time);
	motor[ClawMotor] = 0;
	userPot = true;
}

// ------------------------------------------------------------------- Mobile Lift
void mLift (int speed, int time)
{
	motor[RightMobile] = speed;
	motor[LeftMobile] = speed;
	wait1Msec(time);
	motor[RightMobile] = 0;
	motor[LeftMobile] = 0;
}

// ------------------------------------------------------------------- Mobile Push
void mPush (int speed, int time)
{
	motor[MobilePush] = speed;
	wait1Msec(time);
	motor[MobilePush] = 0;
}

void liftTime (int speed, int time, bool clawHold = false)
{
	if (clawHold)
		motor[ClawMotor] = 30;

	motor[RightLift] = speed;
	motor[LeftLift] = speed;
	wait1Msec(time);
	motor[RightLift] = 0;
	motor[LeftLift] = 0;
}

// ------------------------------------------------------------------- Lift Control
void lift (int height, int speed, bool clawHold = false)
{
	int currentHeight = SensorValue(LiftPot);
	if (clawHold)
		motor[ClawMotor] = 30;

	if (height - currentHeight > 0)
	{
		while (SensorValue(LiftPot) < height)
		{
			motor[RightLift] = -speed * 0.6;
			motor[LeftLift] = -speed * 0.6;
		}
		motor[RightLift] = liftHold;
		motor[LeftLift] = liftHold;
	}

	else
	{
		while (SensorValue(LiftPot) > height)
		{
			motor[RightLift] = speed;
			motor[LeftLift] = speed;
		}
		motor[RightLift] = liftHold;
		motor[LeftLift] = liftHold;
	}
	userPot = true;
}

// ------------------------------------------------------------------- Drive && Lift Controls
void driveLift (int driveSpeed, float distance, int liftSpeed, int height, bool clawHold = false)
{
	setDrive ();
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	float rModMulti = .01;
	if (clawHold)
		motor[ClawMotor] = 30;

	while (abs(SensorValue[LeftEncoder]) < ticks * .1)
	{
		int currentHeight = SensorValue(LiftPot);
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * driveSpeed * rModMulti;

		motor[RightDrive] = driveSpeed/1.5;
		motor[LeftDrive] = driveSpeed/1.5 + rMod;

		if (height - currentHeight > 0)
		{
			motor[RightLift] = -liftSpeed * 0.6;
			motor[LeftLift] = -liftSpeed * 0.6;
		}

		else
		{
			motor[RightLift] = liftSpeed;
			motor[LeftLift] = liftSpeed;
		}
	}

	while (abs(SensorValue[LeftEncoder]) < ticks * .7)
	{
		int currentHeight = SensorValue(LiftPot);
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * driveSpeed * rModMulti;

		motor[RightDrive] = driveSpeed;
		motor[LeftDrive] = driveSpeed + rMod;

		if (height - currentHeight > 0)
		{
			motor[RightLift] = -liftSpeed * 0.6;
			motor[LeftLift] = -liftSpeed * 0.6;
		}

		else
		{
			motor[RightLift] = liftSpeed;
			motor[LeftLift] = liftSpeed;
		}
	}

	while (abs(SensorValue[LeftEncoder]) < ticks)
	{
		int currentHeight = SensorValue(LiftPot);
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * driveSpeed * rModMulti;

		motor[RightDrive] = driveSpeed/3;
		motor[LeftDrive] = driveSpeed/3 + rMod;

		if (height - currentHeight > 0)
		{
			motor[RightLift] = -liftSpeed * 0.6;
			motor[LeftLift] = -liftSpeed * 0.6;
		}

		else
		{
			motor[RightLift] = liftSpeed;
			motor[LeftLift] = liftSpeed;
		}
	}
	motor[RightLift] = liftHold;
	motor[LeftLift] = liftHold;
	driveTime (0, 10);
}

// ------------------------------------------------------------------- Drive && Mobile Goal Push Controls
void drivePush (int speed, int mSec, int pushPower, bool clawHold = false)
{
	motor[RightDrive] = speed;
	motor[LeftDrive] = speed;
	motor[MobilePush] = pushPower;
	wait1Msec(mSec);
	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	motor[MobilePush] = 0;
}

// ------------------------------------------------------------------- Drive && Mobile Goal Reset Controls
void driveReset (int speed, float distance, int pushPower, int mLiftPower, bool clawHold = false)
{
	setDrive ();
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	float rModMulti = .01;
	if (clawHold)
		motor[ClawMotor] = 30;

	while (abs(SensorValue[LeftEncoder]) < ticks * .1)
	{
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed/1.5;
		motor[LeftDrive] = speed/1.5 + rMod;

		motor[MobilePush] = pushPower;
		motor[RightMobile] = mLiftPower;
		motor[LeftMobile] = mLiftPower;
	}

	while (abs(SensorValue[LeftEncoder]) < ticks * .7)
	{
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;

		motor[MobilePush] = pushPower;
		motor[RightMobile] = mLiftPower;
		motor[LeftMobile] = mLiftPower;
	}

	while (abs(SensorValue[LeftEncoder]) < ticks)
	{
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		motor[RightDrive] = speed/3;
		motor[LeftDrive] = speed/3 + rMod;

		motor[MobilePush] = pushPower;
		motor[RightMobile] = mLiftPower;
		motor[LeftMobile] = mLiftPower;
	}

	motor[MobilePush] = 0;
	motor[RightMobile] = 0;
	motor[LeftMobile] = 0;
	driveTime (0, 10);
}

// ------------------------------------------------------------------- Display LCD
void displayLCD()
{
	switch (myAutonomous)
	{
	case 0:
		displayLCDCenteredString(0, autonOne);displayLCDCenteredString(1, "Selected");break;
	case 1:
		displayLCDCenteredString(0, autonTwo);displayLCDCenteredString(1, "Selected");break;
	case 2:
		displayLCDCenteredString(0, autonThree);displayLCDCenteredString(1, "Selected");break;
	case 3:
		displayLCDCenteredString(0, autonFour);displayLCDCenteredString(1, "Selected");break;
	case 4:
		displayLCDCenteredString(0, autonFive);displayLCDCenteredString(1, "Selected");break;
	case 5:
		displayLCDCenteredString(0, autonSix);displayLCDCenteredString(1, "Selected");break;
	case 6:
		displayLCDCenteredString(0, autonSeven);displayLCDCenteredString(1, "Selected");break;
	case 7:
		displayLCDCenteredString(0, autonEight);displayLCDCenteredString(1, "Selected");break;
	case 8:
		displayLCDCenteredString(0, autonNine);displayLCDCenteredString(1, "Selected");break;
	case 9:
		displayLCDCenteredString(0, autonTen);displayLCDCenteredString(1, "Selected");break;
	case 10:
		displayLCDCenteredString(0, autonEleven);displayLCDCenteredString(1, "Selected");break;
	case 11:
		displayLCDCenteredString(0, autonTwelve);displayLCDCenteredString(1, "Selected");break;
	default:
		displayLCDCenteredString(0, autonTest);displayLCDCenteredString(1, "Selected");break;
	}
}

// ------------------------------------------------------------------- Sets Autonomous
void autoSetter (int value, bool select = false)
{
	clearLCDLine(0);
	clearLCDLine(1);

	//Saves Auton In Gloabal Variable
	if (select)
		myAutonomous = value;

	//Displays Set Or Select Accordingly
	if(myAutonomous == value)
		displayLCDCenteredString(1, ">SET<");
	else
		displayLCDCenteredString(1, ">select<");

	//Show Auton Names
	switch(value)
	{
	case 0:
		displayLCDCenteredString(0, autonOne); break;
	case 1:
		displayLCDCenteredString(0, autonTwo); break;
	case 2:
		displayLCDCenteredString(0, autonThree); break;
	case 3:
		displayLCDCenteredString(0, autonFour); break;
	case 4:
		displayLCDCenteredString(0, autonFive); break;
	case 5:
		displayLCDCenteredString(0, autonSix); break;
	case 6:
		displayLCDCenteredString(0, autonSeven); break;
	case 7:
		displayLCDCenteredString(0, autonEight); break;
	case 8:
		displayLCDCenteredString(0, autonNine); break;
	case 9:
		displayLCDCenteredString(0, autonTen); break;
	case 10:
		displayLCDCenteredString(0, autonEleven); break;
	case 11:
		displayLCDCenteredString(0, autonTwelve); break;
	default:
		displayLCDCenteredString(0, autonTest); break;
	}
}

// ------------------------------------------------------------------- Display LCD Auton Selector
void autoSelector()
{
	int choice = 0;
	autoSetter(0);

	while (vexRT[Btn7U] != 1)
	{
		if ((vexRT[Btn7L] == 1) || (vexRT[Btn7R] == 1))
		{
			//Previous Choice
			if (vexRT[Btn7L] == 1)
			{
				if (--choice < 0)
				{
					choice = 9;
				}
			}
			//Next Choice
			if (vexRT[Btn7R] == 1)
			{
				if (++choice > 9)
				{
					choice = 0;
				}
			}
			autoSetter(choice);
		}

		//Select Choice
		if (vexRT[Btn7D] == 1)
			autoSetter(choice, true);
		wait1Msec(120);
	}
	wait1Msec(200);
	return;
}

// ------------------------------------------------------------------- ( High Goal Autonomous )

// ----------------- [RED]
void highGoalRedRight (int cones)
{
	if (cones == 2)
	{
		char HighGoal_RedRight_2;

		//score pre load cone on high goal
		claw (127, 500);
		lift (1200, 80, true);
		wait1Msec(300);
		driveEncoder (60, 16, true);
		lift (1800, 80, true);
		claw (-80, 120);
		wait1Msec(300);
		//turn right and grab second cone
		driveEncoder (-60, 7);
		wait1Msec(300);
		turnGyro (55, 95);
		wait1Msec(300);
		lift (2800, 70);
		driveEncoder (60, 10);
		claw (127, 500);
		//score second cone on high goal
		lift (1100, 80, true);
		wait1Msec(300);
		driveEncoder (-60, 11 , true);
		wait1Msec(300);
		turnGyro (-55, 93, true);
		wait1Msec(300);
		driveEncoder (60, 12, true);
		wait1Msec(200);
		lift (1700, 80);
		claw (-80, 120);
		//attempt to grab a third cone
		driveEncoder (-60, 7);
		wait1Msec(300);
		turnGyro (55, 90);
		wait1Msec(300);
		lift (2800, 100);
		driveEncoder (60, 25);
		claw (127, 500);

		userPot = false;
	}

	else if (cones == 3)
	{
		char HighGoal_RedRight_3;

		//scores pre load
		claw (127, 500);
		liftTime (120, 300, true);
		driveLift (120, 8, 120, 1500, true);
		driveEncoder (120, 6, true);
		liftTime (-80, 100);
		wait1Msec(300);
		claw (-80, 120);
		driveEncoder (-120, 5);
		//turn second cone
		turnGyro (100, 100);
		wait1Msec (50);
		liftTime (-80, 300);
		driveLift (120, 5.5, 120, 3000);
		wait1Msec (50);
		claw (127, 500);
		//scores second cone
		liftTime (120, 400, true);
		turnGyro (-100, 143, true);
		driveLift (120, 7, 120, 1350);
		driveEncoder (120, 2);
		wait1Msec(300);
		liftTime (-100, 150);
		claw (-80, 120);
		wait1Msec(100);
		//turn third cone
		driveEncoder (-120, 5);
		turnGyro (100, 150);
		liftTime (-80, 400);
		driveLift (120, 6, 120, 3000);
		driveEncoder (120, 2);
		wait1Msec(50);
		claw (127, 500);
		//scores third cone
		liftTime (120, 300, true);
		turnGyro (-100, 170, true);
		liftTime (120, 300, true);
		driveLift (120, 8, 120, 1200, true);
		driveEncoder (120, 6, true);
		wait1Msec(300);
		liftTime (-120, 200);
		claw (-80, 120);
		//back off
		driveLift (-120, 8, 120, 3000);
		turnGyro (120, 110);

		userPot = false;
	}
}

void highGoalRedLeft ()
{
	char HighGoal_RedLeft;

	//score pre load cone on high goal
	claw (127, 500);
	lift (1200, 80, true);
	wait1Msec(300);
	driveEncoder (65, 16, true);
	lift (1800, 80, true);
	claw (-80, 120);
	wait1Msec(300);
	//back off
	driveEncoder (-65, 9);
	wait1Msec(300);
	turnGyro (-55, 95);
	wait1Msec(300);
	lift (2800, 70);
	driveEncoder (65, 33);
	claw (127, 500);
	lift (1200, 80, true);
	driveEncoder (-65, 33, true);
	turnGyro (55, 93, true);
	driveEncoder (65, 16, true);
	lift (1700, 127, true);
	claw (-80, 120);
	//back off
	driveEncoder (-127, 9);
	wait1Msec(300);

	userPot = false;
}

// ----------------- [BLUE]

void highGoalBlueRight ()
{
	char HighGoal_BlueRight;

	//score pre load cone on high goal
	claw (127, 500);
	lift (1200, 80, true);
	wait1Msec(300);
	driveEncoder (65, 16, true);
	lift (1800, 80, true);
	claw (-80, 120);
	wait1Msec(300);
	//back off
	driveEncoder (-65, 9);
	wait1Msec(300);
	turnGyro (55, 100);
	wait1Msec(300);
	lift (2800, 70);
	driveEncoder (65, 33);
	claw (127, 500);
	lift (1200, 80, true);
	driveEncoder (-65, 33, true);
	turnGyro (-55 , 87, true);
	driveEncoder (65, 16, true);
	lift (1700, 127, true);
	claw (-80, 120);
	//back off
	driveEncoder (-127, 9);
	wait1Msec(300);

	userPot = false;
}

void highGoalBlueLeft (int cones)
{
	if (cones == 2)
	{
		char HighGoal_BlueLeft_2;

		//score pre load cone on high goal
		claw (127, 500);
		lift (1200, 80, true);
		wait1Msec(300);
		driveEncoder (60, 16, true);
		lift (1800, 80, true);
		claw (-80, 120);
		wait1Msec(300);
		//turn right and grab second cone
		driveEncoder (-60, 7);
		wait1Msec(300);
		turnGyro (-55, 95);
		wait1Msec(300);
		lift (2800, 70);
		driveEncoder (60, 10);
		claw (127, 500);
		//score second cone on high goal
		lift (1100, 80, true);
		wait1Msec(300);
		driveEncoder (-60, 11 , true);
		wait1Msec(300);
		turnGyro (55, 93, true);
		wait1Msec(300);
		driveEncoder (60, 12, true);
		wait1Msec(200);
		lift (1700, 80);
		claw (-80, 120);
		//attempt to grab a third cone
		driveEncoder (-60, 7);
		wait1Msec(300);
		turnGyro (-55, 90);
		wait1Msec(300);
		lift (2800, 100);
		driveEncoder (60, 25);
		claw (127, 500);

		userPot = false;
	}

	else if (cones == 3)
	{
		char HighGoal_BlueLeft_3;

		//scores pre load
		claw (127, 500);
		liftTime (120, 300, true);
		driveLift (120, 8, 120, 1500, true);
		driveEncoder (120, 6, true);
		liftTime (-80, 100);
		wait1Msec(300);
		claw (-80, 120);
		driveEncoder (-120, 5);
		//turn second cone
		turnGyro (-100, 105);
		wait1Msec (50);
		liftTime (-80, 300);
		driveLift (120, 5.5, 120, 3000);
		wait1Msec (50);
		claw (127, 500);
		//scores second cone
		liftTime (120, 400, true);
		turnGyro (100, 143, true);
		driveLift (120, 7, 120, 1350);
		driveEncoder (120, 2);
		wait1Msec(300);
		liftTime (-100, 150);
		claw (-80, 120);
		wait1Msec(100);
		//turn third cone
		driveEncoder (-120, 5);
		turnGyro (-100, 150);
		liftTime (-80, 400);
		driveLift (120, 6, 120, 3000);
		driveEncoder (120, 2);
		wait1Msec(50);
		claw (127, 500);
		//scores third cone
		liftTime (120, 300, true);
		turnGyro (100, 173, true);
		liftTime (120, 300, true);
		driveLift (120, 8, 120, 1200, true);
		driveEncoder (120, 6, true);
		wait1Msec(300);
		liftTime (-120, 200);
		claw (-80, 120);
		//back off
		driveLift (-120, 8, 120, 3000);
		turnGyro (-120, 110);

		userPot = false;
	}
}

// ------------------------------------------------------------------- ( Mobile Goal Autonomous )

// ----------------- [RED]
void mobileGoalRed ()
{
	char MobileGoal_Red;

	//place preload on mobile goal
	claw (127, 500);
	lift (1400, 100, true);
	driveEncoder (100, 40, true);
	lift (2500, 100, true);
	claw (-80, 120);
	lift (2000, 100);
	//picks up mobile goal
	driveEncoder (-60, 13);
	turnGyro (80, 182);
	driveEncoder (-80, 19);
	mLift (100, 1200);
	wait1Msec(300);
	//scores mobile goal in 10 point zone
	driveEncoder (127, 48);
	turnGyro (-80, 120);
	driveTime (-127, 800);
	mLift (127, 1000);
	driveTime (127, 600);

	userPot = false;
}

// ----------------- [BLUE]

void mobileGoalBlue ()
{
	char MobileGoal_Blue;

	//place preload on mobile goal
	claw (127, 500);
	lift (1400, 100, true);
	driveEncoder (100, 40, true);
	lift (2500, 100, true);
	claw (-80, 120);
	lift (2000, 100);
	//picks up mobile goal
	driveEncoder (-60, 13);
	turnGyro (-80, 188);
	//driveEncoder (-80, 19);
	driveTime (-80, 800);
	mLift (100, 1200);
	wait1Msec(300);
	//scores mobile goal in 10 point zone
	driveEncoder (127, 48);
	turnGyro (80, 120);
	driveTime (-127, 800);
	mLift (127, 1000);
	driveTime (127, 600);

	userPot = false;
}

// ------------------------------------------------------------------- Skills
void skills ()
{
	char skills;


	//push then lift
	claw (80, 100);
	lift (2300, 80);
	wait1Msec(300);
	claw (-80, 120);
	driveEncoder (-80, 29);
	mLift (120, 1100);
	wait1Msec(300);
	driveEncoder (80, 22);
	wait1Msec(300);
	turnGyro (-70, 97);
	wait1Msec(300);
	driveEncoder (-80, 8);
	turnGyro (-70, 90);
	driveTime (-120, 1000);
	drivePush (-60, 1500, 127);
	wait1Msec(500);
	driveReset (60, 20, -127, 50);
	mPush (-127, 600);
	mLift (-120, 100);
	turnGyro (-70, 90);
	driveEncoder (80, 14);
	wait1Msec(300);
	turnGyro (-70, 92);
	wait1Msec(300);
	driveEncoder (-120, 24);
	mLift (120, 1100);
	wait1Msec(500);
	driveEncoder (80, 15);
	turnGyro(90, 180);
	driveEncoder (-80, 5);
	driveTime (-80, 650);
	mPush (127, 1300);
	driveEncoder (80, 4);
	turnGyro (-70, 45);
	driveTime (120, 2000);

	userPot = false;
}

// ------------------------------------------------------------------- Test
void test (bool match = false)
{
	char test;

	//    -= Set True For Matches =-
	if (match)
	{
		claw (127, 500);
		liftTime (120, 300, true);
		driveLift (120, 8, 120, 1500, true);
		driveEncoder (120, 6, true);
		liftTime (-80, 100);
		wait1Msec(300);
		claw (-80, 120);
		driveEncoder (-120, 5);
		wait1Msec(15000);

		userPot = false;
	}

	//    -= Actual Tests =-
	else if (!match)
	{


		userPot = false;
	}
}

// ------------------------------------------------------------------- Special
void special ()
{
	char special;

	userPot = false;
}

// ------------------------------------------------------------------- [PRE AUTONOMOUS]
void pre_auton()
{
	intSensor ();
	setDrive ();
}
// ------------------------------------------------------------------- [AUTONOMOUS]
task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);

	switch(myAutonomous)
	{
	case 0: //Skills
		displayLCDCenteredString(0, autonOne); displayLCDCenteredString(1, "Running!"); skills (); break;
	case 1: //High Goal Red
		displayLCDCenteredString(0, autonTwo); displayLCDCenteredString(1, "Running!"); highGoalRedLeft (); break;
	case 2: //High Goal Red L
		displayLCDCenteredString(0, autonThree); displayLCDCenteredString(1, "Running!"); highGoalBlueRight (); break;
	case 3: //High Goal Blue R
		displayLCDCenteredString(0, autonFour); displayLCDCenteredString(1, "Running!"); highGoalRedRight (2); break;
	case 4: //High Goal Blue L
		displayLCDCenteredString(0, autonFive); displayLCDCenteredString(1, "Running!"); highGoalBlueLeft (2); break;
	case 5: //Mobile Goal Red R
		displayLCDCenteredString(0, autonSix); displayLCDCenteredString(1, "Running!"); highGoalRedRight (3); break;
	case 6: //Mobile Goal Red L
		displayLCDCenteredString(0, autonSeven); displayLCDCenteredString(1, "Running!"); highGoalBlueLeft (3); break;
	case 7: //Mobile Goal Blue R
		displayLCDCenteredString(0, autonEight); displayLCDCenteredString(1, "Running!"); mobileGoalRed (); break;
	case 8: //Mobile Goal Left
		displayLCDCenteredString(0, autonNine); displayLCDCenteredString(1, "Running!"); mobileGoalBlue (); break;
	case 9: //Special
		displayLCDCenteredString(0, autonTen); displayLCDCenteredString(1, "Running!"); special (); break;
	default: //Test
		displayLCDCenteredString(0, autonTest); displayLCDCenteredString(1, "Running!"); test (); break;
	}
}

// ------------------------------------------------------------------- [USER CONTROL]
task usercontrol()
{
	//Initialize Variables And Reset LCD
	bool clawBool = false;
	bLCDBacklight = true;
	clearLCDLine (0);
	clearLCDLine (1);
	wait1Msec(100);
	displayLCD();

	while(Eric != RespectsWomen)

	{
		/*------------------------------------------------------------------*\
		//	  ___ ___             ________        .__
		//	 /   |   \            \______ \_______|__|__  __ ____
		//	/    ~    \   ______   |    |  \_  __ \  \  \/ // __ \
		//	\    Y    /  /_____/   |    `   \  | \/  |\   /\  ___/
		//	 \___|_  /            /_______  /__|  |__| \_/  \___  >
		//	       \/                     \/                    \/
		\*------------------------------------------------------------------*/

		//Initialize Variables
		int X2 = 0, Y1 = 0, threshold = 30;

		//Checks Deadzone
		if(abs(vexRT[Ch3]) > threshold)
			Y1 = vexRT[Ch3];
		else if(abs(vexRT[Ch3Xmtr2]) > threshold)
			Y1 = vexRT[Ch3Xmtr2];
		else
			Y1 = 0;
		if(abs(vexRT[Ch4]) > threshold)
			X2 = vexRT[Ch4];
		else if(abs(vexRT[Ch4Xmtr2]) > threshold)
			X2 = vexRT[Ch4Xmtr2];
		else
			X2 = 0;

		//Drive Commands
		motor[RightDrive] = Y1 - X2;
		motor[LeftDrive] = Y1 + X2;

		/*------------------------------------------------------------------*\
		//	.____    .__  _____  __
		//	|    |   |__|/ ____\/  |_
		//	|    |   |  \   __\\   __\
		//	|    |___|  ||  |   |  |
		//	|_______ \__||__|   |__|
		//					\/
		\*------------------------------------------------------------------*/

		//Initilize Variables
		int L1 = 0;

		//Checks Deadzone
		if(abs(vexRT[Ch2]) > threshold)
		{
			L1 = vexRT[Ch2];
			userPot = false;
		}
		else if(abs(vexRT[Ch2Xmtr2]) > threshold)
		{
			L1 = vexRT[Ch2Xmtr2];
			userPot = false;
		}
		else
		{
			L1 = 0;
			if (userPot)
				L1 = -liftHold;
		}

		//Lift Commands
		motor[RightLift] = -L1;
		motor[LeftLift] = -L1;

		//Mobile Goal - Main
		if (vexRT[Btn6D] == 1){
			motor[RightMobile] = -85;
			motor[LeftMobile] = -127;
		}
		else if (vexRT[Btn5D] == 1){
			motor[RightMobile] = 85;
			motor[LeftMobile] = 127;
		}

		//Mobile Goal - Partner
		else if (vexRT[Btn6UXmtr2] == 1)
			motor[RightMobile] = 50;
		else if (vexRT[Btn5UXmtr2] == 1)
			motor[LeftMobile] = 50;
		else if (vexRT[Btn6DXmtr2] == 1)
			motor[RightMobile] = -50;
		else if (vexRT[Btn5DXmtr2] == 1)
			motor[LeftMobile] = -50;

		else if (vexRT[Btn7DXmtr2] == 1){
			motor[RightMobile] = 85;
			motor[LeftMobile] = 127;
		}
		else if (vexRT[Btn8DXmtr2] == 1){
			motor[RightMobile] = -85;
			motor[LeftMobile] = -127;
		}
		else{
			motor[RightMobile] = 0;
			motor[LeftMobile] = 0;
		}

		//Mobile Goal Pusher
		if (vexRT[Btn8D] == 1)
			motor[MobilePush] = 127;
		else if (vexRT[Btn8R] == 1)
			motor[MobilePush] = -127;
		else if (vexRT[Btn7UXmtr2] == 1)
			motor[MobilePush] = 127;
		else if (vexRT[Btn8UXmtr2] == 1)
			motor[MobilePush] = -127;
		else
			motor[MobilePush] = 0;

		//Driver Load Method
		if (vexRT[Btn8L] == 1)
			lift (2100, 70);

		/*------------------------------------------------------------------*\
		//	_________ .__
		//	\_   ___ \|  | _____ __  _  __
		//	/    \  \/|  | \__  \\ \/ \/ /
		//	\     \___|  |__/ __ \\     /
		//	 \______  /____(____  /\/\_/
		//	        \/          \/
		\*------------------------------------------------------------------*/

		//Opens Claw
		if (vexRT[Btn6U] == 1)
		{
			//Starts Timer Once
			while (clawBool)
			{
				clearTimer(T1);
				clawBool = false;
				break;
			}
			//Checks Timer
			if (time1[T1] < 500)
				motor[ClawMotor] = 127;
			else if (time1[T1] > 500)
				motor[ClawMotor] = 30;
		}

		//Closes Claw
		else if (vexRT[Btn5U] == 1)
		{
			motor[ClawMotor] = -127;
			clawBool = true;
			testNum++;
		}
		else
		{
			motor[ClawMotor] = 0;
			clawBool = true;
		}


		/*------------------------------------------------------------------*\
		//	.____   _________ ________
		//	|    |  \_   ___ \\______ \
		//	|    |  /    \  \/ |    |  \
		//	|    |__\     \____|    `   \
		//	|_______ \______  /_______  /
		//					\/      \/        \/
		\*------------------------------------------------------------------*/

		if (vexRT[Btn7D] == 1)
			autoSelector();

		if (vexRT[Btn7U] == 1) //Sets to Test
			myAutonomous = 100;
		else if (vexRT[Btn7R] == 1) //Sets to High Goal Red
			myAutonomous = 5;
		else if (vexRT[Btn7L] == 1) //Sets to High Goal Blue
			myAutonomous = 6;


		displayLCD();

	}
}
