#pragma config(Sensor, in2,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorAccelerometer)
#pragma config(Sensor, dgtl1,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  DriverTemplate, sensorDigitalIn)
#pragma config(Sensor, dgtl7,  LED1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  LED2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  LED3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LED5,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LED6,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           MobileLift,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,            ,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           Lights,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Intake,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           Wrist,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RightLift,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*===================================================================*\
| Initilize Global Variables..........................................|
|---------------------------------------------------------------------|
| these variables are used in methods that deal with auton all the    |
| way to decalaring variables for battery voltage                     |
\*===================================================================*/
int eDriveTicks = 392;
int wheelDiameter = 4;
int myAutonomous = 0;
bool showBattery = false;
string mainBattery, backupBattery;
const int _intakeHoldPower = 20;
int intakeHoldPower = _intakeHoldPower;
bool buddyControl = true;

/*===================================================================*\
| Auton Names.........................................................|
|---------------------------------------------------------------------|
| declares the constant strings for the different auton names that    |
| are then displayed on the LCD display, also contains the open and   |
| close string for the claw method for easier use                     |
\*===================================================================*/
const string autonNull = "Null";
const string autonOne = "Skills";
const string autonTwo = "MOGO 5 Red";
const string autonThree = "MOGO 5 Blue";
const string autonFour = "MOGO 10 Red ";
const string autonFive = "MOGO 10 Blue";
const string autonSix = "MOGO 20 Red";
const string autonSeven = "MOGO 20 Blue";
const string autonEight = "Skys The Limit R";
const string autonNine = "Skys The Limit B";
const string autonTen = "Mix Red";
const string autonEleven = "Mix Blue";
const string autonTwelve = "Special";
const string autonTest = "Test";

/*===================================================================*\
| LED.................................................................|
|---------------------------------------------------------------------|
| used in the NightRider task as an easy way to shut off all the      |
| lights                                                              |
\*===================================================================*/
void lightEmittingDiode (int power){
	SensorValue[LED1] = power;
	SensorValue[LED2] = power;
	SensorValue[LED3] = power;
	SensorValue[LED4] = power;
	SensorValue[LED5] = power;
	SensorValue[LED6] = power;
}

/*------------------------------------------------------------------*\
//	______               _
//	| ___ \             | |
//	| |_/ /___  ___  ___| |_ ___
//	|    // _ \/ __|/ _ \ __/ __|
//	| |\ \  __/\__ \  __/ |_\__ \
//	\_| \_\___||___/\___|\__|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Resets Drive Encoder................................................|
|---------------------------------------------------------------------|
| sets the drive encoders to 0 to then be used throughout the methods |
\*===================================================================*/
void setDrive (){
	// resets encoder values to 0
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
}

/*===================================================================*\
| Resets Gyro.........................................................|
|---------------------------------------------------------------------|
| sets the gyro value to 0 to then be used throughout the methods     |
\*===================================================================*/
void setGyro (){
	// resets the gyro value to 0
	SensorValue[Gyro] = 0;
}

/*===================================================================*\
| Initilize Sensors...................................................|
|---------------------------------------------------------------------|
| completly wipes out all data in the sensors then re-declares them   |
\*===================================================================*/
void intSensor (){
	// sets sensor type to none to start the full sensor reset
	SensorType[Gyro] = sensorNone;
	SensorType[LeftEncoder] = sensorNone;
	SensorType[RightEncoder] = sensorNone;
	// waits 2 sec before setting all the sensors
	wait1Msec(2000);
	SensorType[Gyro] = sensorGyro;
	SensorType[LeftEncoder] = sensorQuadEncoder;
	SensorType[RightEncoder] = sensorQuadEncoder;
	// waits 2 seconds to let gyro initilize properly
	// DO NOT MOVE WHILE THIS IS HAPPENING
	wait1Msec(1500);
}

/*------------------------------------------------------------------*\
//	 _____ _
//	/  ___| |
//	\ `--.| |_ ___  _ __  ___
//	 `--. \ __/ _ \| '_ \/ __|
//	/\__/ / || (_) | |_) \__ \
//	\____/ \__\___/| .__/|___/
//							   |_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Stop Drive..........................................................|
\*===================================================================*/
void stopDrive (){
	// stops drive motors
	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
}

/*===================================================================*\
| Stop DR4B Lift......................................................|                                        |
\*===================================================================*/
void stopLift (){
	// stops DR4B
	motor[RightLift] = 0;
	motor[LeftLift] = 0;
}

/*===================================================================*\
| Stop Wrist..........................................................|
\*===================================================================*/
void stopWrist (){
	// stops cone lift
	motor[Wrist] = 0;
}

/*===================================================================*\
| Stop Intake.........................................................|
\*===================================================================*/
void stopIntake (){
	// stops intake
	motor[Intake] = 0;
}

/*===================================================================*\
| Stop Mobile Goal....................................................|
\*===================================================================*/
void stopMobile (){
	// stop mobile goal motor
	motor[MobileLift] = 0;
}


/*===================================================================*\
| Wait................................................................|
\*===================================================================*/
void wait (){
	wait1Msec(300);
}

/*------------------------------------------------------------------*\
//	______      _
//	|  _  \    (_)
//	| | | |_ __ ___   _____
//	| | | | '__| \ \ / / _ \
//	| |/ /| |  | |\ V /  __/
//	|___/ |_|  |_| \_/ \___|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Drive Time..........................................................|
|---------------------------------------------------------------------|
| allows the use for timing when controling the drive, but also uses  |
| the drive straight commands                                         |
\*===================================================================*/
void driveTime (int speed, int mSec){
	// initilize variable used for right side multiplier
	float rModMulti = .05;

	// starts the timer used for the while loop
	clearTimer(T2);

	// checks for the current time and compares to desiered time
	while (time1[T2] < mSec){
		// calculates the right side modification that needs to be applied
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// applies desiered motor speed and modification
		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;
	}
	// stops the drive motors
	stopDrive ();
}

/*===================================================================*\
| Drive Encoder...... ................................................|
|---------------------------------------------------------------------|
| allows for fine control of the drive, incorperating the use of      |
| inches to and driving straight to be percise in auton               |
\*===================================================================*/
void driveEncoder (int speed, float distance){
	// sets encoders to 0
	setDrive ();
	// calculates the amount of ticks required to reach a set amount of distance (in) using
	// the wheel diameter, PI, and the power of the motor
	float ticks = distance / (wheelDiameter * PI) * eDriveTicks;
	// initilize variable used for right side multiplier
	float rModMulti = .05;

	// checks for the first 10% of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks * .1){
		// calculates the right side modification that needs to be applied
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// reduces the power of the motors to account for drift
		motor[RightDrive] = speed/1.5;
		motor[LeftDrive] = speed/1.5 + rMod;
	}

	// checks for the majority (10% - 80%) of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks * .7){
		// calculates the right side modification that needs to be applied
		int rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// applies the desiered power from the method call
		motor[RightDrive] = speed;
		motor[LeftDrive] = speed + rMod;
	}

	// checks for the last 20% of the encoder ticks
	while (abs(SensorValue[LeftEncoder]) < ticks){
		// calculates the right side modification that needs to be applied
		float rDiff = abs(SensorValue[LeftEncoder]) - abs(SensorValue[RightEncoder]);
		float rMod = sgn(rDiff) * speed * rModMulti;

		// reduces the power of the motor to account for drift as the robot stops
		motor[RightDrive] = speed/3;
		motor[LeftDrive] = speed/3 + rMod;
	}
	// stops the drive motors
	stopDrive ();
}

/*===================================================================*\
| Turn Time...........................................................|
|---------------------------------------------------------------------|
| used to control turns based on time rather than gyro, mostly used   |
| in the turn gyro function to help stop it                           |
\*===================================================================*/
void turnTime (int speed, int mSec){
	// sets the drive motors to turn using a set power
	motor[RightDrive] = -speed;
	motor[LeftDrive] = speed;
	// waits the set amout of mSec to carry out the method
	wait1Msec(mSec);
	// stop drive motors
	stopDrive ();
}

/*===================================================================*\
| Turn Gyro...........................................................|
|---------------------------------------------------------------------|
| uses the gyroscope to accuratly perform turns along with reducing   |
| speed of the turn as the turn progresses                            |
\*===================================================================*/
void turnGyro (int speed, int degrees){
	// sets the gyro value to 0
	setGyro ();
	// calucated the amount required to turn as degrees
	// multiplies by the gyro error for percise turns
	int ticks = degrees * 10;

	// checks for the first 60% of the turn
	while (abs(SensorValue(Gyro)) < ticks * .6){
		// sets motor values to desiered power from the method call
		motor[RightDrive] = -speed;
		motor[LeftDrive] = speed;
	}

	// checks for the next 20% of the turn
	while (abs(SensorValue(Gyro)) < ticks * .8){
		// sets the motor values to a reduced about of power as it
		// reaches the set tick value
		motor[RightDrive] = -speed * .8;
		motor[LeftDrive] = speed * .8;
	}

	// checks for the last 20% of the turn
	while (abs(SensorValue(Gyro)) < ticks){
		// sets the motor values to an even reduced about of power
		// as it reaches the set tick value to stop drift
		motor[RightDrive] = -speed * .55;
		motor[LeftDrive] = speed * .55;
	}
	// briefly moves in the opposite direction for 150 mSec
	turnTime (-speed/2, 150);
}

/*------------------------------------------------------------------*\
//	 _____       _        _
//	|_   _|     | |      | |
//	  | |  _ __ | |_ __ _| | _____
//	  | | | '_ \| __/ _` | |/ / _ \
//	 _| |_| | | | || (_| |   <  __/
//	|_____|_| |_|\__\__,_|_|\_\___|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Intake..............................................................|
|---------------------------------------------------------------------|
| controls the intake in auton by using an input of open or close     |
\*===================================================================*/

/*===================================================================*\
| Use Intake..........................................................|
\*===================================================================*/
void useIntake (){
	// spins intake motor
	motor[Intake] = 127;
}

/*===================================================================*\
| Spit Intake.........................................................|
\*===================================================================*/
void spitIntake (){
	// spits intake motor
	motor[Intake] = -127;
}

/*===================================================================*\
| Hold Intake.........................................................|
\*===================================================================*/
void holdIntake (){
	// holds intake motor
	motor[Intake] = 30;
}

/*------------------------------------------------------------------*\
//	 _     _  __ _
//	| |   (_)/ _| |
//	| |    _| |_| |_ ___
//	| |   | |  _| __/ __|
//	| |___| | | | |_\__ \
//	\_____/_|_|  \__|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Mobile Lift.........................................................|
|---------------------------------------------------------------------|
| moves the mobile goal lift for a specified time and power           |
\*===================================================================*/
void mLiftTime (int speed, int time){
	// sets mobile goal lift to desiered power
	motor[MobileLift] = speed;
	// lets motors move for desiered time
	wait1Msec(time);
	// stop mobile goal motors
	stopMobile ();
}

/*===================================================================*\
| Lift DR4B Time......................................................|
|---------------------------------------------------------------------|
| controls the lift while using time instead of potentiometer values, |
| helps prevent lift from getting stuck/ never reaching pot values    |
\*===================================================================*/
void liftTime (int speed, int time){
	// sets the lift speed
	motor[RightLift] = speed;
	motor[LeftLift] = speed;
	// lets the method carry out for the set time
	wait1Msec(time);
	// stops the lift
	stopLift ();
}

/*===================================================================*\
| Wrist Time..........................................................|
|---------------------------------------------------------------------|
| controls the wrist while using time instead of potentiometer values |
| helps prevent one bar from getting never reaching pot value         |
\*===================================================================*/
void liftWrist (int speed, int time){
	// sets the lift speed
	motor[Wrist] = speed;
	// lets the method carry out for the set time
	wait1Msec(time);
	// stops the lift
	stopWrist ();
}

/*===================================================================*\
| Lift DR4B Potentiometer.............................................|
|---------------------------------------------------------------------|
| controls the lift using the potentiometer, used to reach percise    |
| heights in auton                                                    |
\*===================================================================*/
void lift (int speed, int height){
	// initilize the current height to what it is when the method starts
	int currentHeight = SensorValue(LiftPot);

	// checks if the lift is moving down
	if (height - currentHeight > 0){
		// loops the method while the lift pot is less than the desiered height
		while (SensorValue(LiftPot) < height){
			// sets lift power to move down and reduces power to account for gravity
			motor[RightLift] = -speed * 0.6;
			motor[LeftLift] = -speed * 0.6;
		}
		// stops the lift motors
		stopLift ();
	}

	// checks if the lift is moving down
	else {
		// loops the method while the lift pot is more than the desiered height
		while (SensorValue(LiftPot) > height){
			// sets lift power to move up at desiered power
			motor[RightLift] = speed;
			motor[LeftLift] = speed;
		}
		// stops the lift motors
		stopLift ();
	}
}

/*-----------------------------------------------------------------------*\
//                _                 _____      _           _
//     /\        | |               / ____|    | |         | |
//    /  \  _   _| |_ ___  _ __   | (___   ___| | ___  ___| |_ ___  _ __
//   / /\ \| | | | __/ _ \| '_ \   \___ \ / _ \ |/ _ \/ __| __/ _ \| '__|
//  / ____ \ |_| | || (_) | | | |  ____) |  __/ |  __/ (__| || (_) | |
// /_/    \_\__,_|\__\___/|_| |_| |_____/ \___|_|\___|\___|\__\___/|_|
\*-----------------------------------------------------------------------*/

/*===================================================================*\
| Display LCD.........................................................|
|---------------------------------------------------------------------|
| displays the current auton that is selcted on the LCD               |
\*===================================================================*/
void displayLCD(){
	switch (myAutonomous)
	{
	case 0:
		displayLCDCenteredString(0, autonNull);displayLCDCenteredString(1 ,"Selected");break;
	case 1:
		displayLCDCenteredString(0, autonOne);displayLCDCenteredString(1, "Selected");break;
	case 2:
		displayLCDCenteredString(0, autonTwo);displayLCDCenteredString(1, "Selected");break;
	case 3:
		displayLCDCenteredString(0, autonThree);displayLCDCenteredString(1, "Selected");break;
	case 4:
		displayLCDCenteredString(0, autonFour);displayLCDCenteredString(1, "Selected");break;
	case 5:
		displayLCDCenteredString(0, autonFive);displayLCDCenteredString(1, "Selected");break;
	case 6:
		displayLCDCenteredString(0, autonSix);displayLCDCenteredString(1, "Selected");break;
	case 7:
		displayLCDCenteredString(0, autonSeven);displayLCDCenteredString(1, "Selected");break;
	case 8:
		displayLCDCenteredString(0, autonEight);displayLCDCenteredString(1, "Selected");break;
	case 9:
		displayLCDCenteredString(0, autonNine);displayLCDCenteredString(1, "Selected");break;
	case 10:
		displayLCDCenteredString(0, autonTen);displayLCDCenteredString(1, "Selected");break;
	case 11:
		displayLCDCenteredString(0, autonEleven);displayLCDCenteredString(1, "Selected");break;
	case 12:
		displayLCDCenteredString(0, autonTwelve);displayLCDCenteredString(1, "Selected");break;
	default:
		displayLCDCenteredString(0, autonTest);displayLCDCenteredString(1, "Selected");break;
	}
}

/*===================================================================*\
| Auton Setter........................................................|
|---------------------------------------------------------------------|
| sets the auton and shows the menu display to select an auton        |
\*===================================================================*/
void autoSetter (int value, bool select = false){
	clearLCDLine(0);
	clearLCDLine(1);
	// saves auton in gloabal variable
	if (select)
		myAutonomous = value;

	//displays set or select accordingly
	if(myAutonomous == value)
		displayLCDCenteredString(1, ">SET<");
	else
		displayLCDCenteredString(1, ">select<");

	// shows auton names
	switch(value)
	{
	case 0:
		displayLCDCenteredString(0, autonNull); break;
	case 1:
		displayLCDCenteredString(0, autonOne); break;
	case 2:
		displayLCDCenteredString(0, autonTwo); break;
	case 3:
		displayLCDCenteredString(0, autonThree); break;
	case 4:
		displayLCDCenteredString(0, autonFour); break;
	case 5:
		displayLCDCenteredString(0, autonFive); break;
	case 6:
		displayLCDCenteredString(0, autonSix); break;
	case 7:
		displayLCDCenteredString(0, autonSeven); break;
	case 8:
		displayLCDCenteredString(0, autonEight); break;
	case 9:
		displayLCDCenteredString(0, autonNine); break;
	case 10:
		displayLCDCenteredString(0, autonTen); break;
	case 11:
		displayLCDCenteredString(0, autonEleven); break;
	case 12:
		displayLCDCenteredString(0, autonTwelve); break;
	default:
		displayLCDCenteredString(0, autonTest); break;
	}
}

/*===================================================================*\
| Auton Selector......................................................|
|---------------------------------------------------------------------|
| the framework for being able to use the menu system on the LCD      |
\*===================================================================*/
void autoSelector(){
	// sets choice to 0
	int choice = 0;
	autoSetter(0);

	while (true){
		if ((nLCDButtons == 1) || (nLCDButtons == 4) || (nLCDButtons == 2) || (vexRT[Btn7D] == 1)){
			// previous choice
			if (nLCDButtons == 1){
				if (--choice < 0){
					choice = 12;
				}
			}
			// next choice
			if (nLCDButtons == 4){
				if (++choice > 12){
					choice = 0;
				}
			}
			autoSetter(choice);
		}

		// select choice
		if (nLCDButtons == 2 || vexRT[Btn7D] == 1){
			autoSetter(choice, true);
			break;
		}
		wait1Msec(200);
	}
	wait1Msec(300);
	return;
}

/*------------------------------------------------------------------*\
//  __  __                     _____           _
// |  \/  |                   / ____|         | |
// | \  / | ___ _ __  _   _  | (___  _   _ ___| |_ ___ _ __ ___
// | |\/| |/ _ \ '_ \| | | |  \___ \| | | / __| __/ _ \ '_ ` _ \
// | |  | |  __/ | | | |_| |  ____) | |_| \__ \ ||  __/ | | | | |
// |_|  |_|\___|_| |_|\__,_| |_____/ \__, |___/\__\___|_| |_| |_|
//                                    __/ |
//                                   |___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Display Buddy Control...............................................|
|---------------------------------------------------------------------|
| displays wether the robot is in buddy control or dual control       |
\*===================================================================*/
void displayBuddy (){
	// clear LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	// display current buddy status
	displayLCDCenteredString(0, "Buddy Control:");
	if (buddyControl){displayLCDCenteredString(1, "ON");}
	else {displayLCDCenteredString(1, "OFF");}
}

/*===================================================================*\
| Control Buddy.......................................................|
|---------------------------------------------------------------------|
| controls variables related to buddy control                         |
\*===================================================================*/
void controlBuddy (){
	// loops until you exit
	while (nLCDButtons != 1){
		displayBuddy ();
		if (nLCDButtons == 2)
			buddyControl = false;
		else if (nLCDButtons == 4)
			buddyControl = true;
		// refresh rate
		wait1Msec(50);
	}
	// waits to not interfere with anything else
	wait();
}

void displayIdleSpin (){
	// clear LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	// display current idle spin status
	displayLCDCenteredString(0, "Idle Spin:");
	if (intakeHoldPower == _intakeHoldPower){displayLCDCenteredString(1, "ON");}
	else {displayLCDCenteredString(1, "OFF");}
}

void controlIdleSpin (){
	// loops until you exit
	while (nLCDButtons != 4){
		displayIdleSpin ();
		if (nLCDButtons == 2)
			intakeHoldPower = 0;
		else if (nLCDButtons == 1)
			intakeHoldPower = _intakeHoldPower;
		// refresh rate
		wait1Msec(50);
	}
	wait();
}

/*------------------------------------------------------------------*\
//	 _____         _
//	|_   _|       | |
//	  | | __ _ ___| | _____
//	  | |/ _` / __| |/ / __|
//	  | | (_| \__ \   <\__ \
//	  \_/\__,_|___/_|\_\___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Battery Voltage.....................................................|
\*===================================================================*/
task batteryVoltage () // source http://www.robotc.net/blog/2012/05/18/advanced-applications-with-the-vex-lcd/
{
	while(true)                                                  // An infinite loop to keep the program running until you terminate it
	{
		clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
		clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
		displayNextLCDString(backupBattery);

		//Short delay for the LCD refresh rate
		wait1Msec(100);
	}
	EndTimeSlice();
}

/*===================================================================*\
| Reset Mobile Goal...................................................|
\*===================================================================*/
task resetMobileGoal (){
	// moves mogo back at a reduced speed
	motor[MobileLift] = 127;
	wait1Msec(1500);
	// stops mogo motor and ends task
	stopMobile ();
	stopTask (resetMobileGoal);
}

/*===================================================================*\
| Deploy Mobile Goal..................................................|
\*===================================================================*/
task deployMobileGoal (){
	// moves mogo forward hastly two seconds
	motor[MobileLift] = -9001;
	wait1Msec(1020);
	// stops mogo motor and ends task
	stopMobile ();
	stopTask (deployMobileGoal);
}

/*===================================================================*\
| Deploy Lifts........................................................|
\*===================================================================*/
task deployLift (){
	// loops until lifts reach desiered position
	while (SensorValue[LiftPot] > 2270){
		// swiftly raises lift
		motor[RightLift] = 60;
		motor[LeftLift] = 60;
	}
	// stops lift motors and ends task
	stopLift ();
	stopTask (deployLift);
}

/*===================================================================*\
| Stack Second Cone...................................................|
\*===================================================================*/
task stackSecondCone (){
	holdIntake ();
	lift (80, 2230);
	liftWrist (127, 700);
	wait ();
	liftTime (-100, 150);
	spitIntake ();
	liftTime (127, 150);
	stopTask (stackSecondCone);
}

/*===================================================================*\
| Stack Third Cone....................................................|
\*===================================================================*/
task stackThirdCone (){
	holdIntake ();
	lift (70, 2150);
	liftWrist (127, 700);
	wait();
	liftTime (-50, 200);
	wait();
	spitIntake ();
	liftTime (50, 150);
	stopTask (stackThirdCone);
}

/*===================================================================*\
| Stack Fourth Cone...................................................|
\*===================================================================*/
task stackFourthCone (){
	holdIntake ();
	lift (70, 2000);
	liftWrist (127, 700);
	wait ();
	liftTime (-50, 200);
	spitIntake ();
	wait();
	liftTime (100, 150);
	stopTask (stackFourthCone);
}

/*===================================================================*\
| Night Rider.........................................................|
|---------------------------------------------------------------------|
| makes our cortex look cool                                          |
\*===================================================================*/
task NightRider (){
	//string sDgtl = "dgtl";
	//int index = 7;

	//while (true){
	//	while (index < 12){
	//		sDgtl = sDgtl + index;
	//		lightEmittingDiode(0);
	//		SensorValue[sDgtl] = 1;
	//		wait1Msec(150);
	//		index++;
	//	}

	//	while (index > 7){
	//		sDgtl = sDgtl + index;
	//		lightEmittingDiode(0);
	//		SensorValue[sDgtl] = 1;
	//		wait1Msec(150);
	//		index--;
	//	}
	//}
	while (true){
		lightEmittingDiode (0);
		SensorValue[LED1] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED2] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED3] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED4] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED5] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED6] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED5] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED4] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED3] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED2] = 1;
		wait1Msec(150);
		lightEmittingDiode (0);
		SensorValue[LED1] = 1;
	}
	EndTimeSlice();
}

/*------------------------------------------------------------------*\
//   _____       _            __  __ _
//  / ____|     (_)          |  \/  (_)
// | (___  _ __  _ _ __ ___  | \  / |___  __
//  \___ \| '_ \| | '__/ _ \ | |\/| | \ \/ /
//  ____) | |_) | | | |  __/ | |  | | |>  <
// |_____/| .__/|_|_|  \___| |_|  |_|_/_/\_\
//        | |
//        |_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Red.................................................................|
\*===================================================================*/
void spireMixRed (){

}

/*===================================================================*\
| Blue................................................................|
\*===================================================================*/
void spireMixBlue (){


}


/*------------------------------------------------------------------*\
//	___  ___      _     _ _        _____             _
//	|  \/  |     | |   (_) |      |  __ \           | |
//	| .  . | ___ | |__  _| | ___  | |  \/ ___   __ _| |
//	| |\/| |/ _ \| '_ \| | |/ _ \ | | __ / _ \ / _` | |
//	| |  | | (_) | |_) | | |  __/ | |_\ \ (_) | (_| | |
//	\_|  |_/\___/|_.__/|_|_|\___|  \____/\___/ \__,_|_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Red.................................................................|
\*===================================================================*/
void mogo10Red (){

}
void mogo5Red (){
	// deploy mogo lift and DR4B
	startTask (deployLift);
	startTask (deployMobileGoal);
	holdIntake ();

	// drive forward to mogo and score preload
	driveTime (100, 1500);
	startTask (resetMobileGoal);
	wait1Msec(900);
	driveTime (80, 130);
	motor[Wrist] = 30;
	liftTime (-60, 350);
	spitIntake ();
	wait();
	liftTime (100, 100);

	// grab second cone
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	liftWrist (-127, 200);
	wait();

	// score second and drive to third cone
	startTask (stackSecondCone);
	wait();
	driveTime (80, 300);
	wait1Msec(1000);
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 300);
	liftWrist (-127, 200);
	wait ();

	// score third cone and drive back
	startTask (stackThirdCone);
	driveEncoder (-100, 15);
	wait ();
	turnGyro (100, 34);
	wait1Msec(300);

	// grab and stack fourth cone
	liftWrist (-127, 500);
	useIntake ();
	liftTime (-60, 200);
	driveEncoder (50, 2);
	wait();
	startTask (stackFourthCone);

	// drive back to scoring zone
	//driveEncoder (-100, 10)
	driveTime (60, 100);
	turnGyro (100, 160);
	driveEncoder (100, 15);
	startTask (deployMobileGoal);
	driveEncoder (100, 5);
	wait ();
	driveEncoder (-100, 8);




}

void mogo20RedOther (){
	// deploy mogo lift and DR4B
	startTask (deployLift);
	startTask (deployMobileGoal);
	holdIntake ();

	// drive forward to mogo and score preload
	driveEncoder (100, 43);
	startTask (resetMobileGoal);
	wait1Msec(900);
	driveEncoder (80, 3);
	liftTime (-100, 150);
	spitIntake ();
	wait();

	// grab second cone
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	wait();

	// score second and drive to third cone
	startTask (stackSecondCone);
	wait();
	driveEncoder (-100, 43);

	// turn for third cone
	turnGyro (100, 35);
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-127, 400);
	liftWrist (-127, 300);
	wait();

	// stack n move
	startTask (stackThirdCone);
	wait();
	driveEncoder (-100, 3);
	turnGyro (70, 110);
	driveEncoder (100, 20);
	turnGyro (100, 90);

	// score mogo
	liftTime (70, 200);
	driveTime (127, 800);
	startTask (deployMobileGoal);
	driveTime (127, 800);
	stopTask (deployMobileGoal);
	driveTime (-127, 500);
}

void mogo20Red (){
	// deploy mogo lift and DR4B
	startTask (deployLift);
	startTask (deployMobileGoal);
	holdIntake ();

	// drive forward to mogo and score preload
	driveTime (100, 1500);
	startTask (resetMobileGoal);
	wait1Msec(900);
	driveTime (80, 130);
	motor[Wrist] = 30;
	liftTime (-60, 350);
	spitIntake ();
	wait();
	liftTime (100, 100);

	// grab second cone
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	liftWrist (-127, 200);
	wait();

	// score second and drive to third cone
	startTask (stackSecondCone);
	wait();
	driveTime (80, 300);
	wait1Msec(1000);
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 300);
	liftWrist (-127, 200);
	wait ();

	// score third cone and drive back
	startTask (stackThirdCone);
	//turnGyro (100, 5);
	driveEncoder (-100, 36);
	wait ();
	turnGyro (-100, 45);
	wait();
	driveEncoder (-100, 13);
	wait();
	turnGyro (-100, 90);

	// score mogo
	liftTime (70, 200);
	driveTime (80, 500);
	startTask (deployMobileGoal);
	driveTime (80, 800);
	stopTask (deployMobileGoal);
	stopMobile();
	wait1Msec(500);
	driveTime (-127, 500);
}

void jesusRed (){

}

/*===================================================================*\
| Blue................................................................|
\*===================================================================*/
void mogo10Blue (){

}
void mogo5Blue (){
	// deploy mogo lift and DR4B
	startTask (deployLift);
	startTask (deployMobileGoal);
	holdIntake ();

	// drive forward to mogo and score preload
	driveEncoder (100, 45);
	startTask (resetMobileGoal);
	wait1Msec(900);
	driveEncoder (80, 1);
	liftTime (-100, 150);
	spitIntake ();
	wait();

	// grab second cone
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	wait();

	// score second and drive to third cone
	startTask (stackSecondCone);
	wait();
	driveEncoder (100, 6);
	wait1Msec(1000);
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	//liftWrist (-127, 200);
	wait ();

	// score third cone and drive back
	startTask (stackThirdCone);
	turnGyro (-100, 5);
	driveEncoder (-100, 21);
	wait ();
	turnGyro (-100, 28);

	// grab and stack fourth cone
	liftWrist (-127, 500);
	useIntake ();
	liftTime (-60, 200);
	driveEncoder (50, 4);
	wait();
	startTask (stackFourthCone);

	// drive back to scoring zone
	driveEncoder (-100, 10);
	turnGyro (-100, 140);
	startTask (deployMobileGoal);
	driveEncoder (100, 5);
	wait ();
	driveEncoder (-100, 5);

}

void mogo20Blue (){
	// deploy mogo lift and DR4B
	startTask (deployLift);
	startTask (deployMobileGoal);
	holdIntake ();

	// drive forward to mogo and score preload
	driveTime (100, 1500);
	startTask (resetMobileGoal);
	wait1Msec(900);
	driveTime (80, 130);
	motor[Wrist] = 30;
	liftTime (-60, 350);
	spitIntake ();
	wait();
	liftTime (100, 100);

	// grab second cone
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 200);
	liftWrist (-127, 200);
	wait();

	// score second and drive to third cone
	startTask (stackSecondCone);
	wait();
	driveTime (80, 300);
	wait1Msec(1000);
	useIntake ();
	liftWrist (-127, 500);
	liftTime (-100, 300);
	liftWrist (-127, 200);
	wait ();

	// score third cone and drive back
	startTask (stackThirdCone);
	//turnGyro (100, 5);
	driveEncoder (-100, 36);
	wait ();
	turnGyro (100, 45);
	wait();
	driveEncoder (-100, 13);
	wait();
	turnGyro (100, 90);

	// score mogo
	liftTime (70, 200);
	driveTime (80, 500);
	startTask (deployMobileGoal);
	driveTime (80, 800);
	stopTask (deployMobileGoal);
	stopMobile();
	wait1Msec(500);
	driveTime (-127, 500);
}

void jesusBlue (){

}

/*------------------------------------------------------------------*\
//	 _____     _
//	|  ___|   | |
//	| |____  _| |_ _ __ __ _ ___
//	|  __\ \/ / __| '__/ _` / __|
//	| |___>  <| |_| | | (_| \__ \
//	\____/_/\_\\__|_|  \__,_|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Skills..............................................................|
\*===================================================================*/
void skills (){

}

/*===================================================================*\
| Test................................................................|
\*===================================================================*/
void test (){
	driveEncoder (100, 20);
	wait1Msec(1000);
	driveEncoder(-100, 20);
}

/*===================================================================*\
| Special.............................................................|
\*===================================================================*/
void special (){

}

/*------------------------------------------------------------------*\
//	______            ___        _
//	| ___ \          / _ \      | |
//	| |_/ / __ ___  / /_\ \_   _| |_ ___  _ __
//	|  __/ '__/ _ \ |  _  | | | | __/ _ \| '_ \
//	| |  | | |  __/ | | | | |_| | || (_) | | | |
//	\_|  |_|  \___| \_| |_/\__,_|\__\___/|_| |_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| Pre Auton...........................................................|
|---------------------------------------------------------------------|
| resets sensors and starts the NightRider task                       |
| DO NOT MOVE because of the gyro calibration                         |
\*===================================================================*/
void pre_auton(){
	if (!bIfiAutonomousMode){
		// starts NightRider task because its cool
		startTask (NightRider);
		// set up LCD display
		bLCDBacklight = true;
		displayLCDCenteredString(0, "Do Not Move");
		displayLCDCenteredString(1, "Calibrating");
		// sensor set up
		intSensor ();
		setDrive ();
		// select auton
		if (myAutonomous == 0)
			autoSelector();
		if (bIfiRobotDisabled)
			displayLCD();
	}
}

/*------------------------------------------------------------------*\
//	  ___        _
//	 / _ \      | |
//	/ /_\ \_   _| |_ ___  _ __   ___  _ __ ___   ___  _   _ ___2
//	|  _  | | | | __/ _ \| '_ \ / _ \| '_ ` _ \ / _ \| | | / __|
//	| | | | |_| | || (_) | | | | (_) | | | | | | (_) | |_| \__ \
//	\_| |_/\__,_|\__\___/|_| |_|\___/|_| |_| |_|\___/ \__,_|___/
\*------------------------------------------------------------------*/

/*===================================================================*\
| Autonomous..........................................................|
|---------------------------------------------------------------------|
| starts the autons but actual autons are stored in methods above     |
\*===================================================================*/
task autonomous(){
	clearLCDLine(0);
	clearLCDLine(1);

	switch(myAutonomous)
	{
	case 0:
		displayLCDCenteredString(0, autonNull); displayLCDCenteredString(1, "Running!"); test(); break;
	case 1:
		displayLCDCenteredString(0, autonOne); displayLCDCenteredString(1, "Running!"); skills (); break;
	case 2:
		displayLCDCenteredString(0, autonTwo); displayLCDCenteredString(1, "Running!"); mogo5Red (); break;
	case 3:
		displayLCDCenteredString(0, autonThree); displayLCDCenteredString(1, "Running!"); mogo5Blue (); break;
	case 4:
		displayLCDCenteredString(0, autonFour); displayLCDCenteredString(1, "Running!"); mogo10Red (); break;
	case 5:
		displayLCDCenteredString(0, autonFive); displayLCDCenteredString(1, "Running!"); mogo10Blue (); break;
	case 6:
		displayLCDCenteredString(0, autonSix); displayLCDCenteredString(1, "Running!"); mogo20Red (); break;
	case 7:
		displayLCDCenteredString(0, autonSeven); displayLCDCenteredString(1, "Running!"); mogo20Blue (); break;
	case 8:
		displayLCDCenteredString(0, autonEight); displayLCDCenteredString(1, "Running!"); jesusRed (); break;
	case 9:
		displayLCDCenteredString(0, autonNine); displayLCDCenteredString(1, "Running!"); jesusBlue (); break;
	case 10:
		displayLCDCenteredString(0, autonTen); displayLCDCenteredString(1, "Running!"); spireMixRed (); break;
	case 11:
		displayLCDCenteredString(0, autonEleven); displayLCDCenteredString(1, "Running!"); spireMixBlue (); break;
	case 12:
		displayLCDCenteredString(0, autonTwelve); displayLCDCenteredString(1, "Running!"); special (); break;
	default:
		displayLCDCenteredString(0, autonTest); displayLCDCenteredString(1, "Running!"); test (); break;
	}
	EndTimeSlice();
}

/*------------------------------------------------------------------*\
//	 _   _                 _____             _             _
//	| | | |               /  __ \           | |           | |
//	| | | |___  ___ _ __  | /  \/ ___  _ __ | |_ _ __ ___ | |
//	| | | / __|/ _ \ '__| | |    / _ \| '_ \| __| '__/ _ \| |
//	| |_| \__ \  __/ |    | \__/\ (_) | | | | |_| | | (_) | |
//	 \___/|___/\___|_|     \____/\___/|_| |_|\__|_|  \___/|_|
\*------------------------------------------------------------------*/

/*===================================================================*\
| User Control........................................................|
|---------------------------------------------------------------------|
| controls all the user control related to robot and selection of     |
| auton takes place here                                              |
\*===================================================================*/
task usercontrol(){
	// initilize varibles for user control
	int threshold = 25;
	bool intakeBool = false;
	bool runAuton = false;
	// starts LCD display
	bLCDBacklight = true;
	clearLCDLine (0);
	clearLCDLine (1);
	wait1Msec(100);
	displayLCD();
	// nyeas
	startTask (NightRider);

	// loops while the meme is true
	while(true){
		if (!runAuton){
			/*===================================================================*\
			| H-Base Control......................................................|
			|---------------------------------------------------------------------|
			| sets deadzones for joystick control and uses arcade controls        |
			\*===================================================================*/

			/*--------------------------------*\
			| 				  Buddy Control					 |
			\*--------------------------------*/
			if (buddyControl){
				// initialize drive variables and deadzone
				int X2 = 0, Y1 = 0;

				if ((vexRT[Btn5U] == 1) && (vexRT[Btn6U] == 1)){
					motor[RightDrive] = 35;
					motor[LeftDrive] = 35;
				}

				else if (vexRT[Btn6U] == 1){
					motor[RightDrive] = -50;
					motor[LeftDrive] = 50;
				}

				else if (vexRT[Btn5U] == 1){
					motor[LeftDrive] = -50;
					motor[RightDrive] = 50;
				}



				else {
					// checks deadzone
					if(abs(vexRT[Ch3]) > threshold)
						Y1 = vexRT[Ch3];
					else
						Y1 = 0;
					if(abs(vexRT[Ch4]) > threshold)
						X2 = vexRT[Ch4];
					else
						X2 = 0;

					// sets motor power accordingly
					motor[RightDrive] = Y1 - X2;
					motor[LeftDrive] = Y1 + X2;
				}
			}

			/*--------------------------------*\
			| 				  Single Control				 |
			\*--------------------------------*/
			else if (!buddyControl){
				// initialize drive variables and deadzone
				int X2 = 0, Y1 = 0;

				// checks deadzone
				if(abs(vexRT[Ch3]) > threshold)
					Y1 = vexRT[Ch3];
				else
					Y1 = 0;
				if(abs(vexRT[Ch4]) > threshold)
					X2 = vexRT[Ch4];
				else
					X2 = 0;

				// sets motor power accordingly
				motor[RightDrive] = Y1 - X2;
				motor[LeftDrive] = Y1 + X2;
			}

			/*===================================================================*\
			| Lift Control........................................................|
			|---------------------------------------------------------------------|
			| sets deadzones for joystick control and inverts lift powers         |
			\*===================================================================*/

			/*--------------------------------*\
			| 				  Buddy Control					 |
			\*--------------------------------*/
			if (buddyControl){
				// initilize lift variable
				int L1 = 0, L2 = 0;
				// checks deadzone for DR4B lfit
				if(abs(vexRT[Ch2Xmtr2]) > threshold)
					L1 = vexRT[Ch2Xmtr2];
				else
					L1 = 0;

				// checks deadzone for Wrist
				if(abs(vexRT[Ch3Xmtr2]) > threshold)
					L2 = vexRT[Ch3Xmtr2];
				else {
					L2 = 0;
			}

				// sets motor power accordingly
				motor[RightLift] = -L1;
				motor[LeftLift] = -L1;
				motor[Wrist] = L2;
			}

			/*--------------------------------*\
			| 				  Single Control				 |
			\*--------------------------------*/
			else if (!buddyControl){
				// initilize lift variable
				int L1 = 0, L2 = 0;
				// checks deadzone for DR4B lfit
				if(abs(vexRT[Ch2]) > threshold)
					L1 = vexRT[Ch2];
				else
					L1 = 0;

				if (vexRT[Btn5D] == 1)
					L2 = 127;
				else if (vexRT[Btn6D] == 1)
					L2 = -127;
				else
					L2 = 0;

				// sets motor power accordingly
				motor[RightLift] = -L1;
				motor[LeftLift] = -L1;
				motor[Wrist] = L2;
			}

			/*===================================================================*\
			| Mobile Goal Lift....................................................|
			|---------------------------------------------------------------------|
			| uses back buttons to move mobile goal lift up or down accordingly   |
			\*===================================================================*/

			/*--------------------------------*\
			| 				  Buddy Control					 |
			\*--------------------------------*/
			if (buddyControl){
				// initilize lift variable
				int M1 = 0;
				// moves lift down
				if (vexRT[Btn5D] == 1)
					M1 = 127;
				// moves lift up
				else if (vexRT[Btn6D] == 1)
					M1 = -127;
				// stops lift
				else
					M1 = 0;

				// sets motor power accordingly
				motor[MobileLift] = M1;
			}

			/*--------------------------------*\
			| 				  Single Control				 |
			\*--------------------------------*/
			else if (!buddyControl){
				// initilize lift variable
				int M1 = 0;
				// moves lift down
				if (vexRT[Btn8D] == 1)
					M1 = 127;
				// moves lift up
				else if (vexRT[Btn8L] == 1)
					M1 = -127;
				// stops lift
				else
					M1 = 0;

				// sets motor power accordingly
				motor[MobileLift] = M1;
			}

			/*===================================================================*\
			| Intake Control......................................................|
			|---------------------------------------------------------------------|
			| moves the intake at full power in desiered direction, when claw is  |
			| held for a duration of time the power is reduced to 50 power        |
			\*===================================================================*/

			/*--------------------------------*\
			| 				  Buddy Control					 |
			\*--------------------------------*/
			if (buddyControl){
				// closes intake
				if (vexRT[Btn6UXmtr2] == 1){
					// starts timer once
					while (intakeBool){
						clearTimer(T1);
						intakeBool = false;
						break;
					}
					// checks timer
					if (time1[T1] < 3000)
						motor[Intake] = 127;
					else if (time1[T1] > 3000)
						motor[Intake] = 30;
				}

				// open intake
				else if (vexRT[Btn5UXmtr2] == 1){
					motor[Intake] = -127;
					intakeBool = true;
				}
				// stops intake from moving
				else {
					motor[Intake] = intakeHoldPower;
					intakeBool = true;
				}
			}

			/*--------------------------------*\
			| 				  Single Control				 |
			\*--------------------------------*/
			else if (!buddyControl){
				// closes and holds intake
				if (vexRT[Btn6U] == 1){
					motor[Intake] = 127;
				}

				// open intake
				else if (vexRT[Btn5U] == 1){
					motor[Intake] = -127;
				}
				// stops intake from moving
				else {
					motor[Intake] = intakeHoldPower;
				}
			}

			/*===================================================================*\
			| LCD Control.........................................................|
			|---------------------------------------------------------------------|
			| controls the LCD displays like auton selection and battery voltage  |
			| its a mess                                                          |
			\*===================================================================*/
			// opens auton selector
			if (vexRT[Btn7D] == 1 && myAutonomous != 0)
				autoSelector();
			// opens battery voltage
			if (vexRT[Btn7U] == 1 && !showBattery){
				startTask (batteryVoltage);
				showBattery = true;
				wait1Msec(300);
			}
			else if (vexRT[Btn7U] == 1 && showBattery){
				stopTask (batteryVoltage);
				showBattery = false;
				wait1Msec(300);
			}
			// shows auton selected
			if (!showBattery)
				displayLCD();
			// sets to MOGO Red
			if (vexRT[Btn7R] == 1)
				myAutonomous = 6;
			// sets to MOGO Blue
			if (vexRT[Btn7L] == 1)
				myAutonomous = 7;
			// runs auton
			if (vexRT[Btn8U] == 1){
				runAuton = true;
				startTask (autonomous);
			}
			// runs pre auton
			if(nLCDButtons == 2){
				intSensor();
				autoSelector();
			}

			// stuff for auton thing.


			if (nLCDButtons == 1){
				wait();
				controlBuddy();
			}

			if (nLCDButtons == 4){
				wait();
				controlIdleSpin();
			}

			EndTimeSlice();
		}
		else {
			// stop auton
			if (vexRT[Btn8R] == 1){
				stopTask (autonomous);
				runAuton = false;
			}
			EndTimeSlice();
		}
	}
}
